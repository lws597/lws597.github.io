<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lwscode</title>
  
  <subtitle>lws&#39; blog</subtitle>
  <link href="https://lwscode.com/atom.xml" rel="self"/>
  
  <link href="https://lwscode.com/"/>
  <updated>2021-07-09T07:02:58.073Z</updated>
  <id>https://lwscode.com/</id>
  
  <author>
    <name>lws</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift学习note</title>
    <link href="https://lwscode.com/p/47364/"/>
    <id>https://lwscode.com/p/47364/</id>
    <published>2021-07-08T16:24:54.000Z</published>
    <updated>2021-07-09T07:02:58.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Swift学习note">Swift学习note</h3><h4 id="Swift引入">Swift引入</h4><p>使用 import 语句来引入任何的 Objective-C 框架（或 C 库）到 Swift 程序中。例如 import cocoa 语句导入了使用了 Cocoa 库和API，可以在 Swift 程序中使用它们。</p><p>Cocoa 本身由 Objective-C 语言写成，Objective-C 又是 C 语言的严格超集，所以在 Swift 应用中可以很简单的混入 C 语言代码，甚至是 C++ 代码。</p><h4 id="分号">分号</h4><p>Swift不要求在每行语句的结尾使用分号(;)，但在同一行书写多条语句时，必须用分号隔开：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Cocoa<br><span class="hljs-keyword">var</span> str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>; print (str)<br></code></pre></td></tr></table></figure><p>词法分析或语法分析时应该直接忽略了分号(;)</p><h4 id="标识符">标识符</h4><p>如果一定要使用关键字作为标识符，可以在关键字前后添加重音符号（`），例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> `class` <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Runoob&quot;</span><br></code></pre></td></tr></table></figure><p>比php中的标识符前加@的处理更高级</p><h4 id="Swift空格">Swift空格</h4><p>Swift语言并不是像C/C++，Java那样完全忽视空格，Swift对空格的使用有一定的要求，但是又不像Python对缩进的要求那么严格。</p><p>在Swift中，运算符不能直接跟在变量或常量的后面。例如下面的代码会报错：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>错误信息是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">error: prefix&#x2F;postfix &#39;&#x3D;&#39; is reserved<br></code></pre></td></tr></table></figure><p>意思大概是等号直接跟在前面或后面这种用法是保留的。</p><p>下面的代码还是会报错：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-operator">+</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>错误信息是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">error: consecutive statements on a line must be separated by &#39;;&#39;<br></code></pre></td></tr></table></figure><p>这是因为Swift认为到1+这个语句就结束了，2就是下一个语句了。</p><p>只有这样写才不会报错：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> b <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-operator">+</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>好蠢的设计，为什么不直接忽略空格！？不会用空格来分词吧！那也太不apple了</p><h4 id="Swift数据类型">Swift数据类型</h4><p>Int、UInt、Float、Double、Bool、String、Character（类似cpp）</p><h5 id="类型别名">类型别名</h5><p>类型别名对当前的类型定义了另一个名字，类型别名通过使用typealias关键字来定义。语法格式如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">typealias</span> newname <span class="hljs-operator">=</span> type<br></code></pre></td></tr></table></figure><p>类似c中的typedef</p><h5 id="类型安全">类型安全</h5><p>Swift 是一个类型安全（type safe）的语言。</p><p>由于 Swift 是类型安全的，所以它会在编译代码时进行类型检查（type checks），并把不匹配的类型标记为错误。这可以让开发的时候尽早发现并修复错误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Cocoa<br><br><span class="hljs-keyword">var</span> a <span class="hljs-operator">=</span> <span class="hljs-number">42</span><br>a <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hi&quot;</span><br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><p>以上程序，会在Xcode中报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">error: cannot assign value of type &#39;String&#39; to type &#39;Int&#39;<br>varA &#x3D; &quot;This is hello&quot;<br></code></pre></td></tr></table></figure><p>意思为不能将 ‘String’ 字符串赋值给 ‘Int’ 变量</p><h5 id="常量声明">常量声明</h5><p>常量使用关键字let来声明，语法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> constantName <span class="hljs-operator">=</span> <span class="hljs-operator">&lt;</span>initial value<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h5 id="类型标注">类型标注</h5><p>当声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> constantName:<span class="hljs-operator">&lt;</span>data type<span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">optional</span> initial value<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h4 id="区间运算符">区间运算符</h4><p>Swift 提供了两个区间的运算符</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>闭区间运算符</td><td>闭区间运算符（a…b）定义一个包含从a到b(包括a和b)的所有值的区间，b必须大于等于a。 ‌ 闭区间运算符在迭代一个区间的所有值时是非常有用的，如在for-in循环中</td><td>1…5 区间值为 1, 2, 3, 4 和 5</td></tr><tr><td>半开区间运算符</td><td>半开区间（a…&lt;b）定义一个从a到b但不包括b的区间。 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值</td><td>1…&lt; 5 区间值为 1, 2, 3, 和 4</td></tr></tbody></table><h4 id="字符串函数及运算符">字符串函数及运算符</h4><p>Swift 支持以下几种字符串函数及运算符：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数/运算符 &amp; 描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>isEmpty</strong> 判断字符串是否为空，返回布尔值</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>hasPrefix(prefix: String)</strong> 检查字符串是否拥有特定前缀</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>hasSuffix(suffix: String)</strong> 检查字符串是否拥有特定后缀。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>Int(String)</strong> 转换字符串数字为整型。 实例: <code>let myString: String = &quot;256&quot; let myInt: Int? = Int(myString)</code></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>String.count</strong> Swift 3 版本使用的是 String.characters.count计算字符串的长度</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>utf8</strong> 可以通过遍历 String 的 utf8 属性来访问它的 UTF-8 编码</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>utf16</strong> 可以通过遍历 String 的 utf8 属性来访问它的 utf16 编码</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong>unicodeScalars</strong> 可以通过遍历String值的unicodeScalars属性来访问它的 Unicode 标量编码.</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong>+</strong> 连接两个字符串，并返回一个新的字符串</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong>+=</strong> 连接操作符两边的字符串并将新字符串赋值给左边的操作符变量</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><strong>==</strong> 判断两个字符串是否相等</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><strong>&lt;</strong> 比较两个字符串，对两个字符串的字母逐一比较</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><strong>!=</strong> 比较两个字符串是否不相等</td></tr></tbody></table><h4 id="Swift数组">Swift数组</h4><h5 id="创建数组">创建数组</h5><p>可以使用构造语法来创建一个由特定数据类型构成的空数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> someArray <span class="hljs-operator">=</span> [<span class="hljs-type">SomeType</span>]()<br></code></pre></td></tr></table></figure><p>以下是创建一个初始化大小数组的语法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> someArray <span class="hljs-operator">=</span> [<span class="hljs-type">SomeType</span>](repeating: <span class="hljs-type">InitialValue</span>, count: <span class="hljs-type">NumbeOfElements</span>)<br></code></pre></td></tr></table></figure><p>以下实例创建了一个类型为 Int ，数量为 3，初始值为 0 的空数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> someInts <span class="hljs-operator">=</span> [<span class="hljs-type">Int</span>](repeating: <span class="hljs-number">0</span>, count: <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>以下实例创建了含有三个元素的数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> someInts:[<span class="hljs-type">Int</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br></code></pre></td></tr></table></figure><h4 id="Swift字典">Swift字典</h4><h5 id="创建字典">创建字典</h5><p>可以使用以下语法来创建一个特定类型的空字典：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> someDict <span class="hljs-operator">=</span>  [<span class="hljs-type">KeyType</span>: <span class="hljs-type">ValueType</span>]()<br></code></pre></td></tr></table></figure><p>以下是创建一个空字典，键的类型为 Int，值的类型为 String 的简单语法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> someDict <span class="hljs-operator">=</span> [<span class="hljs-type">Int</span>: <span class="hljs-type">String</span>]()<br></code></pre></td></tr></table></figure><p>以下为创建一个字典的实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> someDict:[<span class="hljs-type">Int</span>:<span class="hljs-type">String</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>:<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&quot;Two&quot;</span>, <span class="hljs-number">3</span>:<span class="hljs-string">&quot;Three&quot;</span>]<br></code></pre></td></tr></table></figure><h5 id="修改字典">修改字典</h5><p>可以使用 updateValue(forKey:) 增加或更新字典的内容。如果 key 不存在，则添加值，如果存在则修改 key 对应的值。updateValue(_:forKey:)方法返回Optional值。实例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Cocoa<br><br><span class="hljs-keyword">var</span> someDict:[<span class="hljs-type">Int</span>:<span class="hljs-type">String</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>:<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&quot;Two&quot;</span>, <span class="hljs-number">3</span>:<span class="hljs-string">&quot;Three&quot;</span>]<br><br><span class="hljs-keyword">var</span> oldVal <span class="hljs-operator">=</span> someDict.updateValue(<span class="hljs-string">&quot;One 新的值&quot;</span>, forKey: <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">var</span> someVar <span class="hljs-operator">=</span> someDict[<span class="hljs-number">1</span>]<br><br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;key = 1 旧的值 <span class="hljs-subst">\(oldVal)</span>&quot;</span> )<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;key = 1 的值为 <span class="hljs-subst">\(someVar)</span>&quot;</span> )<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;key = 2 的值为 <span class="hljs-subst">\(someDict[<span class="hljs-number">2</span>])</span>&quot;</span> )<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;key = 3 的值为 <span class="hljs-subst">\(someDict[<span class="hljs-number">3</span>])</span>&quot;</span> )<br></code></pre></td></tr></table></figure><h5 id="移除Key-Value对">移除Key-Value对</h5><p>可以使用 removeValueForKey() 方法来移除字典 key-value 对。如果 key 存在该方法返回移除的值，如果不存在返回 nil 。实例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Cocoa<br><br><span class="hljs-keyword">var</span> someDict:[<span class="hljs-type">Int</span>:<span class="hljs-type">String</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>:<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&quot;Two&quot;</span>, <span class="hljs-number">3</span>:<span class="hljs-string">&quot;Three&quot;</span>]<br><br><span class="hljs-keyword">var</span> removedValue <span class="hljs-operator">=</span> someDict.removeValue(forKey: <span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;key = 1 的值为 <span class="hljs-subst">\(someDict[<span class="hljs-number">1</span>])</span>&quot;</span> )<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;key = 2 的值为 <span class="hljs-subst">\(someDict[<span class="hljs-number">2</span>])</span>&quot;</span> )<br><span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;key = 3 的值为 <span class="hljs-subst">\(someDict[<span class="hljs-number">3</span>])</span>&quot;</span> )<br></code></pre></td></tr></table></figure><h5 id="字典转换为数组">字典转换为数组</h5><p>提取字典的键值(key-value)对，并转换为独立的数组。实例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Cocoa<br><br><span class="hljs-keyword">var</span> someDict:[<span class="hljs-type">Int</span>:<span class="hljs-type">String</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>:<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&quot;Two&quot;</span>, <span class="hljs-number">3</span>:<span class="hljs-string">&quot;Three&quot;</span>]<br><br><span class="hljs-keyword">let</span> dictKeys <span class="hljs-operator">=</span> [<span class="hljs-type">Int</span>](someDict.keys)<br><span class="hljs-keyword">let</span> dictValues <span class="hljs-operator">=</span> [<span class="hljs-type">String</span>](someDict.values)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出字典的键(key)&quot;</span>)<br><br><span class="hljs-keyword">for</span> (key) <span class="hljs-keyword">in</span> dictKeys &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(key)</span>&quot;</span>)<br>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出字典的值(value)&quot;</span>)<br><br><span class="hljs-keyword">for</span> (value) <span class="hljs-keyword">in</span> dictValues &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(value)</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Swift函数">Swift函数</h4><h5 id="元组作为函数返回值">元组作为函数返回值</h5><p>元组与数组类似，不同的是，元组中的元素可以是任意类型，使用的是圆括号。</p><p>可以用元组（tuple）类型让多个值作为一个复合值从函数中返回。</p><p>下面的这个例子中，定义了一个名为minMax(_:)的函数，作用是在一个Int数组中找出最小值与最大值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Cocoa<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minMax</span>(<span class="hljs-params">array</span>: [<span class="hljs-type">Int</span>])</span> -&gt; (min: <span class="hljs-type">Int</span>, max: <span class="hljs-type">Int</span>) &#123;<br>    <span class="hljs-keyword">var</span> currentMin <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">var</span> currentMax <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> array[<span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span>array.count] &#123;<br>        <span class="hljs-keyword">if</span> value <span class="hljs-operator">&lt;</span> currentMin &#123;<br>            currentMin <span class="hljs-operator">=</span> value<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> value <span class="hljs-operator">&gt;</span> currentMax &#123;<br>            currentMax <span class="hljs-operator">=</span> value<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (currentMin, currentMax)<br>&#125;<br><br><span class="hljs-keyword">let</span> bounds <span class="hljs-operator">=</span> minMax(array: [<span class="hljs-number">8</span>, <span class="hljs-operator">-</span><span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">109</span>, <span class="hljs-number">3</span>, <span class="hljs-number">71</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最小值为 <span class="hljs-subst">\(bounds.min)</span> ，最大值为 <span class="hljs-subst">\(bounds.max)</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h5 id="外部参数名">外部参数名</h5><p>可以在局部参数名前指定外部参数名，中间以空格分隔，外部参数名用于在函数调用时传递给函数的参数。</p><p>可以定义以下两个函数参数名并调用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Cocoa<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pow</span>(<span class="hljs-params">firstArg</span> <span class="hljs-params">a</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">secondArg</span> <span class="hljs-params">b</span>: <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>   <span class="hljs-keyword">var</span> res <span class="hljs-operator">=</span> a<br>   <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span>b &#123;<br>      res <span class="hljs-operator">=</span> res <span class="hljs-operator">*</span> a<br>   &#125;<br>   <span class="hljs-built_in">print</span>(res)<br>   <span class="hljs-keyword">return</span> res<br>&#125;<br>pow(firstArg:<span class="hljs-number">2</span>, secondArg:<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h5 id="可变参数">可变参数</h5><p>可变参数可以接受零个或多个值。函数调用时，可以用可变参数来指定函数参数，其数量是不确定的。</p><p>可变参数通过在变量类型名后面加入（…）的方式来定义</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Cocoa<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">vari</span>&lt;<span class="hljs-type">N</span>&gt;(<span class="hljs-params">members</span>: <span class="hljs-type">N</span>...)</span>&#123;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> members &#123;<br>        <span class="hljs-built_in">print</span>(i)<br>    &#125;<br>&#125;<br>vari(members: <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h5 id="引用参数">引用参数</h5><p>一般默认在函数中定义的参数都是常量参数，也就是这个参数你只可以查询使用，不能改变它的值。</p><p>如果想要声明一个变量参数，可以在参数定义前加 inout 关键字，这样就可以改变这个参数的值了。</p><p>例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">getName</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">name</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">String</span>)</span><br></code></pre></td></tr></table></figure><p>此时这个 name 值可以在函数中改变。</p><p>一般默认的参数传递都是传值调用的，而不是传引用。所以传入的参数在函数内改变，并不影响原来的那个参数。传入的只是这个参数的副本。</p><p>当传入的参数作为输入输出参数时，需要在参数名前加 &amp; 符，表示这个值可以被函数修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Swift学习note&quot;&gt;Swift学习note&lt;/h3&gt;
&lt;h4 id=&quot;Swift引入&quot;&gt;Swift引入&lt;/h4&gt;
&lt;p&gt;使用 import 语句来引入任何的 Objective-C 框架（或 C 库）到 Swift 程序中。例如 import cocoa 语</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Macos自用配置</title>
    <link href="https://lwscode.com/p/20018/"/>
    <id>https://lwscode.com/p/20018/</id>
    <published>2021-07-02T17:50:29.000Z</published>
    <updated>2021-07-02T17:54:34.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="macos自用配置">macos自用配置</h3><p>浏览器——google chrome</p><p>翻墙——v2rayU</p><p>终端——iterm2</p><p>笔记——typora</p><p>git tool——sourcetree</p><h4 id="开发环境">开发环境</h4><p>最先安装完成Xcode，然后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">xcode-select --install<br></code></pre></td></tr></table></figure><p>配置常用开发环境（其中python3 version 3.8，需brew install python@3.9）</p><h4 id="安装homebrewcn">安装homebrewcn</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/bin/zsh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span><br></code></pre></td></tr></table></figure><h4 id="安装常用工具">安装常用工具</h4><p>python、node、yarn、ccls、fzf、ranger、typora、sourcetree、qt-creator、autojump、thefuck、visual-studio-code、neovim、microsoft-remote-desktop，只需要分别</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew install <span class="hljs-comment">#+ 以上包名</span><br></code></pre></td></tr></table></figure><p>安装过程中部分包会提示在.zshrc中添加配置，自行添加</p><h4 id="修改pip源">修改pip源</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir ~/.pip<br>vim ~/.pip/pip.conf<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">[global]<br>index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple<br>[install]<br>trusted-host &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn<br></code></pre></td></tr></table></figure><h4 id="升级pip">升级pip</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip3 install --upgrade pip<br></code></pre></td></tr></table></figure><h4 id="安装pygments、pynvim">安装pygments、pynvim</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install -g pygments<br>pip install -g pynvim<br></code></pre></td></tr></table></figure><h4 id="修改npm、yarn源">修改npm、yarn源</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br>yarn config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h4 id="iterm2配置">iterm2配置</h4><h5 id="先安装ohmyzsh">先安装ohmyzsh</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span><br></code></pre></td></tr></table></figure><h5 id="下载ohmyzsh-plugin">下载ohmyzsh plugin</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting<br>git <span class="hljs-built_in">clone</span> git://github.com/zsh-users/zsh-autosuggestions <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions<br>git <span class="hljs-built_in">clone</span> https://github.com/paulirish/git-open.git <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/git-open<br></code></pre></td></tr></table></figure><h5 id="zshrc修改">.zshrc修改</h5><p>自用插件，<code>plugin=(git)</code>括号里面添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">plugins&#x3D;(git zsh-autosuggestions zsh-syntax-highlighting autojump web-search extract last-working-dir sudo pip thefuck colored-man-pages colorize safe-paste git-open vi-mode copyfile copydir gitfast command-not-found history)<br></code></pre></td></tr></table></figure><h5 id="alias添加">alias添加</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">alias vim&#x3D;&quot;nvim&quot;<br>alias vi&#x3D;&quot;nvim&quot;<br>alias rm&#x3D;&quot;rm -i&quot;<br>alias cp&#x3D;&quot;cp -i&quot;<br>alias cls&#x3D;&quot;clear&quot;<br>alias cat&#x3D;&quot;ccat&quot;<br>alias ra&#x3D;&quot;ranger&quot;<br>alias -s c&#x3D;copyfile<br>alias -s cpp&#x3D;copyfile<br></code></pre></td></tr></table></figure><p>终端里<code>zsh</code>即可加载配置</p><h4 id="安装字体">安装字体</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew tap homebrew/cask-fonts<br>brew install --cask font-sauce-code-pro-nerd-font<br></code></pre></td></tr></table></figure><p>补充一些缺失的符号</p><h4 id="nvim-spacevim配置">nvim+spacevim配置</h4><h5 id="安装spacevim">安装spacevim</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl -sLf https://spacevim.org/cn/install.sh | bash<br></code></pre></td></tr></table></figure><h5 id="自用配置">自用配置</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/lws597/SpaceVim.git .SpaceVim.d<br></code></pre></td></tr></table></figure><p>终端里nvim即可下载插件</p><h4 id="配色主题">配色主题</h4><p>Xcode、vscode、iterm2、zsh自用配色主题为<code>dracula</code></p><p><a href="https://draculatheme.com/">https://draculatheme.com/</a></p><p><a href="https://github.com/dracula/dracula-theme">https://github.com/dracula/dracula-theme</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;macos自用配置&quot;&gt;macos自用配置&lt;/h3&gt;
&lt;p&gt;浏览器——google chrome&lt;/p&gt;
&lt;p&gt;翻墙——v2rayU&lt;/p&gt;
&lt;p&gt;终端——iterm2&lt;/p&gt;
&lt;p&gt;笔记——typora&lt;/p&gt;
&lt;p&gt;git tool——sourcetree&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Javascript学习note</title>
    <link href="https://lwscode.com/p/1579/"/>
    <id>https://lwscode.com/p/1579/</id>
    <published>2021-04-26T08:40:26.000Z</published>
    <updated>2021-04-26T11:20:15.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js语法">js语法</h2><h3 id="js语法学习demo">js语法学习<a href="https://github.com/lws597/web/tree/master/js">demo</a></h3><p>js作为一个脚本语言，语法学习简单。其中typeof操作符较为有意思，无类型语言竟然还有类型检查机制，回头给<a href="https://github.com/lws597/xlang">自制语言</a>添加一个typeof关键字。js的null和true/false为保留关键字，<a href="https://github.com/lws597/xlang">自制语言</a>的null和true/false也可设置为关键字，直接解析成0/1</p><h3 id="var-let-const">var &amp; let &amp; const</h3><p>let 声明的变量只在 let 命令所在的代码块内有效<br>const 声明一个只读的常量，一旦声明，常量的值就不能改变</p><p>for循环{}中多用let</p><h3 id="for…in-for…of">for…in &amp; for…of</h3><p>在循环对象属性的时候，使用for…in，for…in循环得到的是key<br>在遍历数组的时候的时候使用for…of，for…of循环得到的是value</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> aArray) &#123;<br>    <span class="hljs-built_in">console</span>.log(aArray[index]);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> aArray) &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="">&gt;&gt; &amp; &gt;&gt;&gt;</h3><p>运算符&gt;&gt;&gt;执行无符号右移位运算。它把无符号的32位整数所有数位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1000</span> &gt;&gt; <span class="hljs-number">8</span>);  <span class="hljs-comment">//返回值3</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1000</span> &gt;&gt;&gt; <span class="hljs-number">8</span>);  <span class="hljs-comment">//返回值3</span><br></code></pre></td></tr></table></figure><p>对于负数来说，无符号右移将使用0来填充所有的空位，同时会把负数作为正数来处理，所得结果会非常大</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(-<span class="hljs-number">1000</span> &gt;&gt; <span class="hljs-number">8</span>);  <span class="hljs-comment">//返回值 -4</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-number">1000</span> &gt;&gt;&gt; <span class="hljs-number">8</span>);  <span class="hljs-comment">//返回值 16777212</span><br></code></pre></td></tr></table></figure><h2 id="js刷题">js刷题</h2><h3 id="leetcode1189"><a href="https://leetcode-cn.com/problems/maximum-number-of-balloons">leetcode1189</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=1189 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [1189] “气球” 的最大数量</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">text</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxNumberOfBalloons = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> map = &#123;<span class="hljs-string">&#x27;a&#x27;</span> : <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;b&#x27;</span> : <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;o&#x27;</span> : <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;l&#x27;</span> : <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;n&#x27;</span> : <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ch <span class="hljs-keyword">of</span> text) &#123;<br>        map[ch]++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(map[<span class="hljs-string">&#x27;a&#x27;</span>], map[<span class="hljs-string">&#x27;b&#x27;</span>], map[<span class="hljs-string">&#x27;o&#x27;</span>] &gt;&gt; <span class="hljs-number">1</span>, map[<span class="hljs-string">&#x27;l&#x27;</span>] &gt;&gt; <span class="hljs-number">1</span>, map[<span class="hljs-string">&#x27;n&#x27;</span>]);<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br><br></code></pre></td></tr></table></figure><h3 id="leetcode944"><a href="https://leetcode-cn.com/problems/delete-columns-to-make-sorted">leetcode944</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=944 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [944] 删列造序</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">strs</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minDeletionSize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; strs.length - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (strs[j][i] &gt; strs[j + <span class="hljs-number">1</span>][i]) &#123;<br>                ans++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br><br></code></pre></td></tr></table></figure><h3 id="leetcode908"><a href="https://leetcode-cn.com/problems/smallest-range-i">leetcode908</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=908 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [908] 最小差值 I</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">K</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> smallestRangeI = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">A, K</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (A.length == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> delta = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, A) - <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, A) - (K &lt;&lt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> delta &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : delta;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br><br></code></pre></td></tr></table></figure><h3 id="leetcode38"><a href="https://leetcode-cn.com/problems/count-and-say">leetcode38</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=38 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [38] 外观数列</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countAndSay = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> pre = <span class="hljs-string">&quot;1&quot;</span>, cur = <span class="hljs-string">&quot;1&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        pre = cur;<br>        cur = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (r &lt; pre.length) &#123;<br>            <span class="hljs-keyword">while</span> (pre[l] === pre[r] &amp;&amp; r &lt; pre.length) &#123;<br>                r++;<br>            &#125;<br>            cur += (r - l).toString() + pre[l];<br>            l = r;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;js语法&quot;&gt;js语法&lt;/h2&gt;
&lt;h3 id=&quot;js语法学习demo&quot;&gt;js语法学习&lt;a href=&quot;https://github.com/lws597/web/tree/master/js&quot;&gt;demo&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;js作为一个脚本语言，语法学习简单。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Wps实习四个月后</title>
    <link href="https://lwscode.com/p/3770/"/>
    <id>https://lwscode.com/p/3770/</id>
    <published>2021-04-22T07:55:36.000Z</published>
    <updated>2021-06-20T13:48:30.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="wps实习四个月后的一些思考和新规划">wps实习四个月后的一些思考和新规划</h2><p>wps的实习已经告一段落，玩了一段时间，迷茫了一段时间，整理代码一段时间，现在写一篇思考。</p><h3 id="wps实习内容">wps实习内容</h3><p>在wps mac组实习四个月，接手的需求有：</p><ol><li><p>移植pc功能</p><ol><li>Excel批量计算</li></ol></li><li><p>交互功能</p><ol><li>空格键进入图片预览</li><li>双指滑动（滚轮）移动图片</li><li>双指拍&amp;双指捏缩放图片</li><li>双指旋旋转wps对象</li><li>双指/右键拖复制wps对象</li></ol></li><li><p>优化需求</p><ol><li>多级窗口modal规范</li><li>新建文本框默认设置添加选项</li><li>复制图片清晰度优化</li><li>Excel单个单元格复制形式改为纯文本</li></ol></li><li><p>半成品需求</p><ol><li>光标icon替换为高清图</li><li>Excel底部sheet平滑移动</li><li>文本框添加只复制文本功能</li><li>三指捏需求</li></ol></li></ol><p>感觉这些需求都挺无聊的，所以才交给一个实习生写吧。多级窗口modal规范，该需求阅读了大量qt源码。触控板扩展需求考察了一堆开源代码，学习了objective-c和swift。也就这两个需求有点意思。</p><h3 id="实习过程技术成长">实习过程技术成长</h3><p>刚入职先学习公司代码规范、工程规范，和一些工作流程。第一次用到心心念念的mac，也花了点时间来熟悉，用过很多发行版Linux，上手mac也很快。wps产品由用qt+c/cpp完成，技术方面先学习qt。第一个需求移植pc已有的Excel批量计算功能，需要添加的代码都在一起，不需要调试，直接上手敲码就好，qt方面也只需要学习dialog的创建，和事件的处理。第二个需求空格键进入图片预览，该有的api都有，但需要找到适合修改的代码块，因为不会调试所以花了一个多星期，还是最后组长教会了我调试来定位代码和了解功能的执行流程。后面都是一些调api的需求，以及学会qt某部分的使用就能写的需求。多级窗口modal规范需求，考察了很久才定位到qt的bug（pc没问题，mac有问题，应该第一时间就测试一下是不是qt的bug），为解决bug阅读了大量qt源码，对qt的一些特性有了更深了了解，学习框架还是得直接读源码。qt源码面向对象，以c++11为标准（qt6以c++17为标准），范型编程到处都是，可读性很好，比wps代码好的多。离职前的需求是mac触控板相关的，网上资料很少，只有github上有几个项目，为了看懂代码就去学了objective-c，顺便学了swift（语法方面c/cpp yyds，oc真反人类，swift也习惯不了）。做了一些考察才知道apple有Private API这个东西，mac触控板增强软件都用了这部分api，wps不可能用的，产品的一些需求也就得打回了。不用写多指需求了，但多指滑、多指捏在继续考察，应该可以通过触控点的坐标识别手势，但自定义手势多了可能就不能做到精准识别了。</p><h3 id="实习过程不足">实习过程不足</h3><p>实习过程还是有一些问题暴露出来。最大的问题应该就是不喜欢码字，提测邮件都不想写，周报和提测邮件被cue过，组长让我写开发文档也一次没写过。感觉码字的问题需要正视一下，不仅是工作流程中的常规码字，还有一些技术分享内容，这也是对个人和工作都有帮助的。所以打算以后以该blog为契机多写一些技术分享内容。由于实习疏忽了算法题，现在很多题的解法都生疏了。现在回头看刷算法题确实可以提升思维，也是为了以后面试做准备，应该让刷算法题成为一个习惯。之前刷了一堆不同难度的算法题，几乎覆盖了所有类型的算法，但没有做过一次归纳总结，也没写过一篇算法文章。今后每天刷一定量题，也要做归纳总结写稿。大学技术积累只有c/cpp，其他技术都不会，不会一个框架，没有达到技术上的广度。今后需要多积累一些其他技术，学习一下go、web前端、机器学习，和一些较火的框架。新技术的积累是从头开始，学习过程也要通过blog形式记录一下。虽说大学只学了c/cpp，但深度也是没达到的，引以为傲的语言方面和大佬交流后发现，还是有一堆东西不知道的。c/cpp的一些附属技术也只是了解。短期内没有转技术的想法，所以技术方面还是以c/cpp方面为主。wps实习是一次接触大型的工程代码，为了更好的写工程代码，还需要学习重构相关的技巧，架构知识入门，熟练掌握范型编程，设计模式熟练选择和运用。</p><h3 id="对未来的焦虑">对未来的焦虑</h3><p>老实说工作和我想象中的并不一样，你不是只需要一心一意的写好你的代码就好。还需要和其他人对接，完成自己的okr，完成小组的okr。牺牲个人，顺应小组的方向。个人对公司来说就是一颗螺丝钉，在我所做的工作压根看不到自己的痕迹，做的技术也是没意思的CURD，写一些shit需求的业务代码，和一些前辈聊了之后发现大厂也有这般问题。之前从来没想过这个问题，就算想到了也不会觉得这是个问题。实习离职后也思考一番人生，还冒出自己创业的可笑想法。b站UP主推荐《软技能》一书，在书中找到了一些问题的答案。工作了就要尽量别让工作侵占生活，下班后可以自己做饭、去健身，养一只猫，做一些技术之外的事。而打工这件事应该要以平常心对待，工作是公司的，个人发展是自己的。技术方面下班后刷几个算法题，看几篇技术文章，也要做到技术产出。</p><p>好好学习吧。技术和money都会有的！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;wps实习四个月后的一些思考和新规划&quot;&gt;wps实习四个月后的一些思考和新规划&lt;/h2&gt;
&lt;p&gt;wps的实习已经告一段落，玩了一段时间，迷茫了一段时间，整理代码一段时间，现在写一篇思考。&lt;/p&gt;
&lt;h3 id=&quot;wps实习内容&quot;&gt;wps实习内容&lt;/h3&gt;
&lt;p&gt;在w</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vim查找&amp;替换</title>
    <link href="https://lwscode.com/p/5304/"/>
    <id>https://lwscode.com/p/5304/</id>
    <published>2021-04-20T03:09:18.000Z</published>
    <updated>2021-04-26T11:15:10.712Z</updated>
    
    <content type="html"><![CDATA[<h1>vim中的查找与替换</h1><h5 id="1-查找"><strong>1.查找</strong></h5><p>在normal模式下按下<code>/</code>即可进入查找模式，输入要查找的字符串并按下回车。 Vim会跳转到第一个匹配。按下<code>n</code>查找下一个，按下<code>N</code>查找上一个。</p><p>Vim查找支持正则表达式，例如<code>/vim$</code>匹配行尾的<code>&quot;vim&quot;</code>。 需要查找特殊字符需要转义，例如<code>/vim\$</code>匹配<code>&quot;vim$&quot;</code>。</p><h5 id="2-大小写敏感查找"><strong>2.大小写敏感查找</strong></h5><p>在查找模式中加入<code>\c</code>表示大小写不敏感查找，<code>\C</code>表示大小写敏感查找。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;foo\c<br></code></pre></td></tr></table></figure><p>将会查找所有的<code>&quot;foo&quot;</code>,<code>&quot;FOO&quot;</code>,<code>&quot;Foo&quot;</code>等字符串。</p><h5 id="3-大小写敏感配置"><strong>3.大小写敏感配置</strong></h5><p>Vim 默认采用大小写敏感的查找，为了方便我们常常将其配置为大小写不敏感：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot; 设置默认进行大小写不敏感查找<br>set ignorecase<br>&quot; 如果有一个大写字母，则切换到大小写敏感查找<br>set smartcase <br></code></pre></td></tr></table></figure><blockquote><p>将上述设置粘贴到你的<code>~/.vimrc</code>，重新打开Vim即可生效</p></blockquote><h5 id="4-查找当前单词"><strong>4.查找当前单词</strong></h5><p>在normal模式下按下<code>*</code>即可查找光标所在单词（word）， 要求每次出现的前后为空白字符或标点符号。例如当前为<code>foo</code>， 可以匹配<code>foo bar</code>中的<code>foo</code>，但不可匹配<code>foobar</code>中的<code>foo</code>。 这在查找函数名、变量名时非常有用。</p><p>按下<code>g*</code>即可查找光标所在单词的字符序列，每次出现前后字符无要求。 即<code>foo bar</code>和<code>foobar</code>中的<code>foo</code>均可被匹配到。</p><h5 id="5-查找与替换"><strong>5.查找与替换</strong></h5><p><code>:s</code>（substitute）命令用来查找和替换字符串。语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:&#123;作用范围&#125;s&#x2F;&#123;目标&#125;&#x2F;&#123;替换&#125;&#x2F;&#123;替换标志&#125;<br></code></pre></td></tr></table></figure><p>例如<code>:%s/foo/bar/g</code>会在全局范围(<code>%</code>)查找<code>foo</code>并替换为<code>bar</code>，所有出现都会被替换（<code>g</code>）</p><h5 id="6-作用范围"><strong>6.作用范围</strong></h5><p>作用范围分为当前行、全文、选区等等。</p><p>当前行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:s&#x2F;foo&#x2F;bar&#x2F;g<br></code></pre></td></tr></table></figure><p>全文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:%s&#x2F;foo&#x2F;bar&#x2F;g<br></code></pre></td></tr></table></figure><p>选区，在Visual模式下选择区域后输入<code>:</code>，Vim即可自动补全为 <code>:'&lt;,'&gt;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:&#39;&lt;,&#39;&gt;s&#x2F;foo&#x2F;bar&#x2F;g<br></code></pre></td></tr></table></figure><p>2-11行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:5,12s&#x2F;foo&#x2F;bar&#x2F;g<br></code></pre></td></tr></table></figure><p>当前行<code>.</code>与接下来两行<code>+2</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:.,+2s&#x2F;foo&#x2F;bar&#x2F;g<br></code></pre></td></tr></table></figure><h2 id="替换标志">替换标志</h2><p>上文中命令结尾的<code>g</code>即是替换标志之一，表示全局<code>global</code>替换（即替换目标的所有出现）。 还有很多其他有用的替换标志：</p><p>空替换标志表示只替换从光标位置开始，目标的第一次出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:%s&#x2F;foo&#x2F;bar<br></code></pre></td></tr></table></figure><p><code>i</code>表示大小写不敏感查找，<code>I</code>表示大小写敏感：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">:%s&#x2F;foo&#x2F;bar&#x2F;i<br># 等效于模式中的\c（不敏感）或\C（敏感）<br>:%s&#x2F;foo\c&#x2F;bar<br></code></pre></td></tr></table></figure><p><code>c</code>表示需要确认，例如全局查找<code>&quot;foo&quot;</code>替换为<code>&quot;bar&quot;</code>并且需要确认：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:%s&#x2F;foo&#x2F;bar&#x2F;gc<br></code></pre></td></tr></table></figure><p>回车后Vim会将光标移动到每一次<code>&quot;foo&quot;</code>出现的位置，并提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">replace with bar (y&#x2F;n&#x2F;a&#x2F;q&#x2F;l&#x2F;^E&#x2F;^Y)?<br></code></pre></td></tr></table></figure><p>按下<code>y</code>表示替换，<code>n</code>表示不替换，<code>a</code>表示替换所有，<code>q</code>表示退出查找模式， <code>l</code>表示替换当前位置并退出。<code>^E</code>与<code>^Y</code>是光标移动快捷键，参考： <a href="http://harttle.com/2015/11/07/vim-cursor.html">Vim中如何快速进行光标移</a></p><h2 id="大小写敏感查找">大小写敏感查找</h2><p>在查找模式中加入<code>\c</code>表示大小写不敏感查找，<code>\C</code>表示大小写敏感查找。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;foo\c<br></code></pre></td></tr></table></figure><p>将会查找所有的<code>&quot;foo&quot;</code>,<code>&quot;FOO&quot;</code>,<code>&quot;Foo&quot;</code>等字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;vim中的查找与替换&lt;/h1&gt;
&lt;h5 id=&quot;1-查找&quot;&gt;&lt;strong&gt;1.查找&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;在normal模式下按下&lt;code&gt;/&lt;/code&gt;即可进入查找模式，输入要查找的字符串并按下回车。 Vim会跳转到第一个匹配。按下&lt;code&gt;n&lt;/c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="https://lwscode.com/p/9423/"/>
    <id>https://lwscode.com/p/9423/</id>
    <published>2021-04-20T03:07:52.000Z</published>
    <updated>2021-04-26T11:15:10.709Z</updated>
    
    <content type="html"><![CDATA[<h1>Interview Q&amp;A STL</h1><h2 id="B-树（B-tree）、B-树（B±tree）">B 树（B-tree）、B+ 树（B±tree）</h2><h3 id="特点">特点</h3><ul><li>一般化的二叉查找树（binary search tree）</li><li>“矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）</li></ul><h3 id="应用">应用</h3><ul><li>大部分文件系统、数据库系统都采用B树、B+树作为索引结构</li></ul><h3 id="区别">区别</h3><ul><li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点。</li><li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li></ul><h3 id="B树的优点">B树的优点</h3><ul><li>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</li></ul><h3 id="B-树的优点">B+树的优点</h3><ul><li>非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li><li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li></ul><h2 id="STL-容器">STL 容器</h2><table><thead><tr><th>容器</th><th>底层数据结构</th><th>时间复杂度</th><th>有无序</th><th>可不可重复</th><th>其他</th></tr></thead><tbody><tr><td>array</td><td>数组</td><td>随机读改 O(1)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td>vector</td><td>数组</td><td>随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td>deque</td><td>双端队列</td><td>头尾插入、头尾删除 O(1)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td>forward_list</td><td>单向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td>list</td><td>双向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td>stack</td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td>queue</td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td>priority_queue</td><td>vector + max-heap</td><td>插入、删除 O(log2n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td>set</td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td>multiset</td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td>map</td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td>multimap</td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td>unordered_set</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td>unordered_multiset</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td>unordered_map</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td>unordered_multimap</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Interview Q&amp;amp;A STL&lt;/h1&gt;
&lt;h2 id=&quot;B-树（B-tree）、B-树（B±tree）&quot;&gt;B 树（B-tree）、B+ 树（B±tree）&lt;/h2&gt;
&lt;h3 id=&quot;特点&quot;&gt;特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一般化的二叉查找树（binary </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Socket</title>
    <link href="https://lwscode.com/p/34204/"/>
    <id>https://lwscode.com/p/34204/</id>
    <published>2021-04-20T03:05:34.000Z</published>
    <updated>2021-04-26T11:15:10.712Z</updated>
    
    <content type="html"><![CDATA[<p>我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket的基本函数，这些都是本文想介绍的。本文的主要内容如下：</p><ul><li>1、网络中进程之间如何通信？</li><li>2、Socket是什么？</li><li>3、socket的基本操作<ul><li>3.1、socket()函数</li><li>3.2、bind()函数</li><li>3.3、listen()、connect()函数</li><li>3.4、accept()函数</li><li>3.5、read()、write()函数等</li><li>3.6、close()函数</li></ul></li><li>4、socket中TCP的三次握手建立连接详解</li><li>5、socket中TCP的四次握手释放连接详解</li></ul><h1>1、网络中进程之间如何通信？</h1><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><p>但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机，而传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><p>使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。</p><h1>2、什么是Socket？</h1><p>上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。</p><blockquote><h3 id="socket一词的起源">socket一词的起源</h3><p>在组网领域的首次使用是在1970年2月12日发布的文献<a href="http://datatracker.ietf.org/doc/rfc33/">IETF RFC33</a>中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”</p></blockquote><h1>3、socket的基本操作</h1><p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p><h2 id="3-1、socket-函数">3.1、socket()函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">int socket(int domain, int type, int protocol);<br></code></pre></td></tr></table></figure><p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而**socket()**用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li><li>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。</li></ul><p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p><p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p><h2 id="3-2、bind-函数">3.2、bind()函数</h2><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br></code></pre></td></tr></table></figure><p>函数的三个参数分别为：</p><ul><li><p>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：一个 const struct sockaddr* 指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">struct sockaddr_in &#123;<br>      sa_family_t    sin_family; &#x2F;* address family: AF_INET *&#x2F;<br>    in_port_t      sin_port;   &#x2F;* port in network byte order *&#x2F;<br>      struct in_addr sin_addr;   &#x2F;* internet address *&#x2F;<br>&#125;;<br>  <br></code></pre></td></tr></table></figure></li></ul><p>/* Internet address. <em>/<br>struct in_addr {<br>uint32_t       s_addr;     /</em> address in network byte order */<br>};</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>ipv6对应的是：<br><br></code></pre></td></tr></table></figure><p>struct sockaddr_in6 {<br>sa_family_t     sin6_family;   /* AF_INET6 <em>/<br>in_port_t       sin6_port;     /</em> port number <em>/<br>uint32_t        sin6_flowinfo; /</em> IPv6 flow information <em>/<br>struct in6_addr sin6_addr;     /</em> IPv6 address <em>/<br>uint32_t        sin6_scope_id; /</em> Scope ID (new in 2.4) */<br>};</p><p>struct in6_addr {<br>unsigned char   s6_addr[16];   /* IPv6 address */<br>};</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>Unix域对应的是：<br><br></code></pre></td></tr></table></figure><p>#define UNIX_PATH_MAX    108</p><p>struct sockaddr_un {<br>sa_family_t sun_family;               /* AF_UNIX <em>/<br>char        sun_path[UNIX_PATH_MAX];  /</em> pathname */<br>};</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">  <br>- addrlen：对应的是地址的长度。<br><br>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。<br><br>&gt; ### 网络字节序与主机字节序<br>&gt;<br>&gt; **主机字节序**就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：<br>&gt;<br>&gt; 　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>&gt;<br>&gt; 　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br>&gt;<br>&gt; **网络字节序**：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。**由于TCP&#x2F;IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。**字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。<br>&gt;<br>&gt; 所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。<br><br>## 3.3、listen()、connect()函数<br><br>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。<br><br></code></pre></td></tr></table></figure><p>int listen(int sockfd, int backlog);<br>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。<br><br>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。<br><br>## 3.4、accept()函数<br><br>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I&#x2F;O操作了，即类同于普通文件的读写I&#x2F;O操作。<br><br></code></pre></td></tr></table></figure><p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。<br><br>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。<br><br>## 3.5、read()、write()等函数<br><br>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I&#x2F;O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I&#x2F;O操作有下面几组：<br><br>- read()&#x2F;write()<br>- recv()&#x2F;send()<br>- readv()&#x2F;writev()<br>- recvmsg()&#x2F;sendmsg()<br>- recvfrom()&#x2F;sendto()<br><br>我推荐使用recvmsg()&#x2F;sendmsg()函数，这两个函数是最通用的I&#x2F;O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：<br><br></code></pre></td></tr></table></figure><pre><code>   #include &lt;unistd.h&gt;   ssize_t read(int fd, void *buf, size_t count);   ssize_t write(int fd, const void *buf, size_t count);   #include &lt;sys/types.h&gt;   #include &lt;sys/socket.h&gt;   ssize_t send(int sockfd, const void *buf, size_t len, int flags);   ssize_t recv(int sockfd, void *buf, size_t len, int flags);   ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,                  const struct sockaddr *dest_addr, socklen_t addrlen);   ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,                    struct sockaddr *src_addr, socklen_t *addrlen);   ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);   ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。<br><br>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。<br><br>其它的我就不一一介绍这几对I&#x2F;O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send&#x2F;recv。<br><br>## 3.6、close()函数<br><br>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。<br><br></code></pre></td></tr></table></figure><p>#include &lt;unistd.h&gt;<br>int close(int fd);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。<br><br>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。<br><br># 4、socket中TCP的三次握手建立连接详解<br><br>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：<br><br>- 客户端向服务器发送一个SYN J<br>- 服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1<br>- 客户端再想服务器发一个确认ACK K+1<br><br>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：<br><br>[![image](https:&#x2F;&#x2F;images.cnblogs.com&#x2F;cnblogs_com&#x2F;skynet&#x2F;201012&#x2F;201012122157476286.png)](http:&#x2F;&#x2F;images.cnblogs.com&#x2F;cnblogs_com&#x2F;skynet&#x2F;201012&#x2F;201012122157467258.png)<br><br>图1、socket中发送的TCP三次握手<br><br>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。<br><br>&gt; 总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。<br><br># 5、socket中TCP的四次握手释放连接详解<br><br>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：<br><br>[![image](https:&#x2F;&#x2F;images.cnblogs.com&#x2F;cnblogs_com&#x2F;skynet&#x2F;201012&#x2F;201012122157494693.png)](http:&#x2F;&#x2F;images.cnblogs.com&#x2F;cnblogs_com&#x2F;skynet&#x2F;201012&#x2F;201012122157487616.png)<br><br>图2、socket中发送的TCP四次握手<br><br>图示过程如下：<br><br>- 某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；<br>- 另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；<br>- 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；<br>- 接收到这个FIN的源发送端TCP对它进行确认。<br><br>这样每个方向上都有一个FIN和ACK。<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RBTree</title>
    <link href="https://lwscode.com/p/60718/"/>
    <id>https://lwscode.com/p/60718/</id>
    <published>2021-04-20T03:04:42.000Z</published>
    <updated>2021-04-26T11:15:10.709Z</updated>
    
    <content type="html"><![CDATA[<h1>RedBlack_Tree</h1><h2 id="五个条件">五个条件</h2><ol><li>节点非黑即红</li><li>根节点是黑色的</li><li>叶节点(NIL)是黑色的</li><li>如果一个节点是红色的，则它的两个子节点都是黑色的</li><li>从根节点出发到所有叶节点路径上，黑色节点数量相同</li></ol><p>最短路径全黑，节点数a，最长路径有相同多个黑色节点（条件5）</p><p>，红色节点不能连续（条件4），节点数2a</p><h2 id="调整策略">调整策略</h2><p>插入节点站在祖父节点看</p><p>删除调整站在父节点看</p><h3 id="插入调整">插入调整</h3><p>用带有两个黑色的NIL的新节点替换NIL叶节点</p><p>为了方便调整，新结点初始为红色（黑色节点影响条件5）</p><h4 id="情况一">情况一</h4><p>插入节点的父节点是黑色</p><p>直接插入</p><h4 id="情况二">情况二</h4><p>插入节点的父节点和叔节点都是红色</p><p>父节点、叔节点染成黑色，祖父节点染成红色</p><h4 id="情况三LL">情况三LL</h4><p>插入节点的父节点是红色，叔节点是黑色，插入节点是父节点的左孩子，父节点是祖父节点的左孩子</p><p>祖父节点右旋，祖父节点染成红色，父节点染成黑色</p><h4 id="情况四LR">情况四LR</h4><p>插入节点的父节点是红色，叔节点是黑色，插入节点是父节点的右孩子，父节点是祖父节点的左孩子</p><p>父节点左旋，转换为情况三（祖父节点右旋，祖父节点染成红色，父节点染成黑色）</p><h3 id="删除调整">删除调整</h3><h4 id="情况一-2">情况一</h4><p>兄弟节点是红色</p><p>父节点左旋，父节点染成红色，兄弟节点染成黑色</p><h4 id="情况二-2">情况二</h4><p>父节点、兄弟节点和兄弟节点的子节点都是黑色</p><p>父节点左旋，父节点染成红色</p><h4 id="情况三">情况三</h4><p>父节点红色，兄弟节点和兄弟节点的子节点都是黑色</p><p>父节点左旋</p><h4 id="情况四">情况四</h4><p>父节点任意颜色，兄弟节点的右儿子红色，删除节点是父节点的左儿子</p><p>父节点左旋，交换父节点、兄弟节点的颜色，兄弟节点的右孩子染成黑色</p><h4 id="情况五">情况五</h4><p>父节点任意颜色，兄弟节点的左儿子红色，删除节点是父节点的左儿子</p><p>兄弟节点染成红色，兄弟节点的左儿子染成黑色，兄弟节点右旋，转换为情况四</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RedBlack_Tree&lt;/h1&gt;
&lt;h2 id=&quot;五个条件&quot;&gt;五个条件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;节点非黑即红&lt;/li&gt;
&lt;li&gt;根节点是黑色的&lt;/li&gt;
&lt;li&gt;叶节点(NIL)是黑色的&lt;/li&gt;
&lt;li&gt;如果一个节点是红色的，则它的两个子节点都是黑色的&lt;/li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Printf</title>
    <link href="https://lwscode.com/p/12527/"/>
    <id>https://lwscode.com/p/12527/</id>
    <published>2021-04-20T03:03:19.000Z</published>
    <updated>2021-04-26T11:15:10.712Z</updated>
    
    <content type="html"><![CDATA[<p>printf输出颜色和ANSI控制码(高亮,下划线,闪烁,光标位置,清屏等)</p><p>颜色：</p><p>#define NONE “/033[m”</p><p>#define RED “/033[0;32;31m”</p><p>#define LIGHT_RED “/033[1;31m”</p><p>#define GREEN “/033[0;32;32m”</p><p>#define LIGHT_GREEN “/033[1;32m”</p><p>#define BLUE “/033[0;32;34m”</p><p>#define LIGHT_BLUE “/033[1;34m”</p><p>#define DARY_GRAY “/033[1;30m”</p><p>#define CYAN “/033[0;36m”</p><p>#define LIGHT_CYAN “/033[1;36m”</p><p>#define PURPLE “/033[0;35m”</p><p>#define LIGHT_PURPLE “/033[1;35m”</p><p>#define BROWN “/033[0;33m”</p><p>#define YELLOW “/033[1;33m”</p><p>#define LIGHT_GRAY “/033[0;37m”</p><p>#define WHITE “/033[1;37m”</p><p>比如：</p><p>printf(“/033[31m ####-----&gt;&gt; /033[32m” “hello/n” “/033[m”)</p><p>int main()</p><p>{</p><p>printf( CYAN “current function is %s &quot; GREEN &quot; file line is %d/n” NONE,</p><p><strong>FUNCTION</strong>, <strong>LINE</strong> );</p><p>fprintf(stderr, RED “current function is %s &quot; BLUE &quot; file line is %d/n” NONE,</p><p><strong>FUNCTION</strong>, <strong>LINE</strong> );</p><p>return 0;</p><p>}</p><p>颜色分为背景色和字体色，30~39用来设置字体色，40~49设置背景：</p><p>背景色 字体色</p><p>40: 黑 30: 黑</p><p>41: 红 31: 红</p><p>42: 绿 32: 绿</p><p>43: 黄 33: 黄</p><p>44: 蓝 34: 蓝</p><p>45: 紫 35: 紫</p><p>46: 深绿 36: 深绿</p><p>47: 白色 37: 白色</p><p>记得在打印完之后，把颜色恢复成NONE，不然再后面的打印都会跟着变色。</p><p>另外，还可以加一些ANSI控制码。加颜色只是以下控制码中的一种：</p><p>/033[0m 关闭所有属性</p><p>/033[1m 设置高亮度</p><p>/033[4m 下划线</p><p>/033[5m 闪烁</p><p>/033[7m 反显</p><p>/033[8m 消隐</p><p>/033[30m – /033[37m 设置前景色</p><p>/033[40m – /033[47m 设置背景色</p><p>/033[nA 光标上移n行</p><p>/033[nB 光标下移n行</p><p>/033[nC 光标右移n行</p><p>/033[nD 光标左移n行</p><p>/033[y;xH设置光标位置</p><p>/033[2J 清屏</p><p>/033[K 清除从光标到行尾的内容</p><p>/033[s 保存光标位置</p><p>/033[u 恢复光标位置</p><p>/033[?25l 隐藏光标</p><p>/033[?25h 显示光标</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;printf输出颜色和ANSI控制码(高亮,下划线,闪烁,光标位置,清屏等)&lt;/p&gt;
&lt;p&gt;颜色：&lt;/p&gt;
&lt;p&gt;#define NONE “/033[m”&lt;/p&gt;
&lt;p&gt;#define RED “/033[0;32;31m”&lt;/p&gt;
&lt;p&gt;#define LIGHT_RE</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Note4</title>
    <link href="https://lwscode.com/p/34591/"/>
    <id>https://lwscode.com/p/34591/</id>
    <published>2021-04-20T03:01:49.000Z</published>
    <updated>2021-04-26T11:15:10.712Z</updated>
    
    <content type="html"><![CDATA[<h1>DAY05</h1><h2 id="输出函数说明">输出函数说明</h2><p>printf函数</p><ul><li>头文件:stdio.h</li><li>原型:int printf(const char *format,…);</li><li>format:格式控制字符串</li><li>…:可变参数列表</li><li>返回值:输出字符类型</li></ul><h2 id="输出函数说明-2">输出函数说明</h2><p>scanf函数</p><ul><li>头文件:stdio.h</li><li>原型:int scanf(const char *format,…);</li><li>format:格式控制字符</li><li>…:可变参数列表</li><li>返回值:成功读入列表</li></ul><p>请使用printf函数,求解一个数字n的十进制表示的数字位数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include&lt;stdio.h&gt;<br>int main()&#123;<br>    int n;<br>    while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;<br>        printf(&quot; has %d digits\n&quot;,printf(&quot;%d&quot;,n));<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>请写一个程序,读入一个行字符串(可能包含空格),输出这个字符串中字符的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include&lt;stdio.h&gt;<br>int main()&#123;<br>    char str[100];<br>    while(scanf(&quot;%[^\n]s&quot;,str)!&#x3D;EOF) &#123;<br>        getchar();<br>        printf(&quot; has %d chars\n&quot;,printf(&quot;%s&quot;,str));<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sprintf和fprintf代码演示">sprintf和fprintf代码演示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include &lt;stdio.h&gt;<br>#define swap(a, b) &#123; \<br>    __typeof(a) temp &#x3D; a;\<br>    a &#x3D; b, b &#x3D; temp; \<br>&#125;<br><br>int main() &#123;<br>    printf(&quot;%c\n&quot;, 97);<br>    int n;<br>    scanf(&quot;%d&quot;, &amp;n);<br>    printf(&quot;%04d\n&quot;, n);<br>    char str[100], buff[100], *p &#x3D; str, *q &#x3D; buff;<br>    sprintf(str, &quot;%d.%d.%d.%d&quot;, 192,168,1,10);<br>    printf(&quot;str&#x3D;%s\n&quot;, str);<br>    if (n &amp; 1) &#123;<br>        sprintf(q, &quot;(%s)&quot;, p);<br>        swap(p, q);<br>    &#125;<br>    if (n &amp; 2) &#123;<br>        sprintf(q, &quot;[%s]&quot;, p);<br>        swap(p, q);<br>    &#125;<br>    if (n &amp; 4) &#123;<br>        sprintf(q, &quot;&#123;%s&#125;&quot;, p);<br>        swap(p, q);<br>    &#125;<br>    FILE *fout &#x3D; fopen(&quot;output&quot;, &quot;w&quot;);<br>    fprintf(stdout, &quot;stdout &#x3D; %s\n&quot;, p);<br>    fprintf(stderr, &quot;stderr &#x3D; %s\n&quot;, p);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DAY05&lt;/h1&gt;
&lt;h2 id=&quot;输出函数说明&quot;&gt;输出函数说明&lt;/h2&gt;
&lt;p&gt;printf函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头文件:stdio.h&lt;/li&gt;
&lt;li&gt;原型:int printf(const char *format,…);&lt;/li&gt;
&lt;li&gt;forma</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Note3</title>
    <link href="https://lwscode.com/p/17758/"/>
    <id>https://lwscode.com/p/17758/</id>
    <published>2021-04-20T03:01:06.000Z</published>
    <updated>2021-04-26T11:15:10.711Z</updated>
    
    <content type="html"><![CDATA[<h1>DAY04</h1><h2 id="使用github管理代码">使用github管理代码</h2><h3 id="创建一个空目录">创建一个空目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">mkdir hzoj<br>cd hzoj<br>pwd<br></code></pre></td></tr></table></figure><h3 id="把目录变成git仓库">把目录变成git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">git init<br></code></pre></td></tr></table></figure><h3 id="把文件添加到仓库">把文件添加到仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">git add *<br></code></pre></td></tr></table></figure><h3 id="把文件提交到仓库">把文件提交到仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">git commit *<br></code></pre></td></tr></table></figure><h3 id="查看结果">查看结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">git status<br></code></pre></td></tr></table></figure><h3 id="把本地库的所有内容推送到远程库上">把本地库的所有内容推送到远程库上</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">git remote add origin git@github.com:lws597&#x2F;HZOJ.git<br>git push -u origin master<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DAY04&lt;/h1&gt;
&lt;h2 id=&quot;使用github管理代码&quot;&gt;使用github管理代码&lt;/h2&gt;
&lt;h3 id=&quot;创建一个空目录&quot;&gt;创建一个空目录&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Note2</title>
    <link href="https://lwscode.com/p/34207/"/>
    <id>https://lwscode.com/p/34207/</id>
    <published>2021-04-20T03:00:15.000Z</published>
    <updated>2021-04-26T11:15:10.711Z</updated>
    
    <content type="html"><![CDATA[<h1>DAY03</h1><h2 id="Linux极简入门">Linux极简入门</h2><h3 id="文件与目录的管理">文件与目录的管理</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>ls</td><td>显示文件及目录信息</td></tr><tr><td>cp</td><td>拷贝</td></tr><tr><td>rm</td><td>删除</td></tr><tr><td>mv</td><td>移动</td></tr></tbody></table><h3 id="cp拷贝">cp拷贝</h3><p>cp [irapdslu] <sour> <dest></p><p>选项</p><ul><li>-i若文件存在，询问用户</li><li>-r递归复制</li><li>-apdr的集合</li><li>-p连同文件属性一起拷贝</li><li>-d若源文件为连接文件的属性，则复制连接文件的属性</li><li>-s拷贝为软连接</li><li>-l拷贝为硬连接</li><li>-u源文件比目的文件新才拷贝</li></ul><h3 id="rm删除">rm删除</h3><p>rm [irf] &lt;dir_or_file&gt;</p><p>选项</p><ul><li>-i互动模式</li><li>-r递归删除</li><li>-fforce</li></ul><h3 id="mv移动">mv移动</h3><p>mv [ifu] &lt;source…&gt; <dest></p><ul><li>mv source1 source2 souce3 dir</li></ul><p>选项</p><ul><li>-i互动模式</li><li>-fforce</li><li>-u源文件更新才会移动</li></ul><h3 id="文件内容的查阅">文件内容的查阅</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cat</td><td>正向连接读</td></tr><tr><td>tac</td><td>反向连接读</td></tr><tr><td>nl</td><td>输出行号显示文件</td></tr><tr><td>more</td><td>一页一页的显示文件内容</td></tr><tr><td>less</td><td>与more相似，但是可以上下翻看</td></tr><tr><td>head</td><td>只看头几行</td></tr><tr><td>tail</td><td>只看末尾几行</td></tr></tbody></table><h3 id="cat正向连续读">cat正向连续读</h3><p>cat [-AbEnTv] <file></p><p>选项:</p><ul><li>-A:相当于-vET</li><li>-v:列出看不出的字符</li><li>-E:显示断行符为$</li><li>-T:显示TAB为^T</li><li>-b:列出行号</li><li>-n:列出行号,连同空行也编号</li></ul><h3 id="tac反向连续读">tac反向连续读</h3><p>刚好与cat相反,从最后一行开始打印</p><h3 id="nl输出行号显示文件">nl输出行号显示文件</h3><p>nl [-bnw] <file></p><p>选项</p><ul><li>-b:行号指定的方式</li><li><ul><li>-b a:相当于cat -n</li><li>-b t:相当于cat -b</li></ul></li><li>-n:列出行号的表示方法</li><li><ul><li>-n ln:行号在屏幕最左边显示</li><li>-n rn:行号在自己字段的最右边显示</li><li>-n rz:行号在自己字段的最右边显示,前面自动补全0</li></ul></li><li>-w <num>:行号所占位数</li></ul><h3 id="more按页查看">more按页查看</h3><p>more file</p><ul><li>/string向下查找string关键字</li><li>:f显示文件名称和当前显示的行数</li><li>q离开</li></ul><h3 id="less按页查看">less按页查看</h3><p>less file</p><ul><li>/string向下查找n:继续向下查找</li><li>/?string反向查找N:继续反向查询</li></ul><h3 id="head查看头几行">head查看头几行</h3><p>head [-n num] <file></p><ul><li>-n num:显示前num行</li></ul><h3 id="tail查看末尾几行">tail查看末尾几行</h3><p>tail [-n num] <file></p><ul><li>-n num:显示文件后num行</li><li>-f:force</li></ul><p>如何查看一个文件的101行到120行?</p><p>man ls | nl -b a -w 5 -n rz | head -n 120 | tail -n 20</p><h3 id="man手册">man手册</h3><ol><li>man手册页分为下面几个部分:</li><li>普通命令</li><li>内核提供的系统调用</li><li>库调用(C库函数)</li><li>特殊文件(大多数在/dev目录下)和设备</li><li>文件格式规范</li><li>游戏</li><li>杂项(及其规范)</li><li>系统管理命令(通常需要root权限)和守护进程</li></ol><h2 id="配置wifi">配置wifi</h2><h3 id="打开终端-执行命令">打开终端,执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo service NetworkManager stop#关闭NetworkManager<br>sudo service NetworkManager start#开启NetworkManager<br></code></pre></td></tr></table></figure><h3 id="执行命令-查看网卡命名">执行命令,查看网卡命名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ifcongif -a<br></code></pre></td></tr></table></figure><h3 id="更改interfaces配置">更改interfaces配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo vim &#x2F;etc&#x2F;network&#x2F;interfaces<br></code></pre></td></tr></table></figure><p>在文本框中输入,保存并退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">auto wlp3s0<br>allow-hotplug wlp3s0<br>iface wlp3s0 inet dhcp<br>pre-up wpa_supplicant -Dwext -i wlp3s0 -c &#x2F;etc&#x2F;wpa_supplicant&#x2F;wpa_supplicant.conf -B<br></code></pre></td></tr></table></figure><h3 id="编辑wpa-supplicant-conf">编辑wpa_supplicant.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo vim &#x2F;etc&#x2F;wpa_supplicant&#x2F;wpa_supplicant.conf <br></code></pre></td></tr></table></figure><p>在文本框中输入,保存并退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">country&#x3D;CN<br>ctrl_interface&#x3D;DIR&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant GROUP&#x3D;netdev<br>update_config&#x3D;1<br>network&#x3D;&#123;<br>    ssid&#x3D;&quot;HaiZei_Tech&quot;<br>    psk&#x3D;&quot;HaiZei731.&quot;<br>    scan_ssid&#x3D;1<br>    priority&#x3D;3<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更改DNS">更改DNS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo vim &#x2F;etc&#x2F;resolv.conf<br></code></pre></td></tr></table></figure><p>nameserver 8.8.8.8</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DAY03&lt;/h1&gt;
&lt;h2 id=&quot;Linux极简入门&quot;&gt;Linux极简入门&lt;/h2&gt;
&lt;h3 id=&quot;文件与目录的管理&quot;&gt;文件与目录的管理&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Note1</title>
    <link href="https://lwscode.com/p/34015/"/>
    <id>https://lwscode.com/p/34015/</id>
    <published>2021-04-20T02:59:05.000Z</published>
    <updated>2021-04-26T11:15:10.711Z</updated>
    
    <content type="html"><![CDATA[<h1>DAY01</h1><h2 id="更新源">更新源</h2><h3 id="打开终端（Ctrl-Alt-T），执行命令">打开终端（Ctrl+Alt+T），执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo gedit &#x2F;etc&#x2F;apt&#x2F;sources.list<br></code></pre></td></tr></table></figure><h3 id="将文本框的内容删除，粘贴以下内容-保存并退出">将文本框的内容删除，粘贴以下内容,保存并退出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse<br>deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse<br>deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse<br>deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse<br>deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse<br>deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse<br>deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse<br>deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse<br>deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse<br>deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>·预先加载的应用（apt-get install preload）能识别一个用户最常用的<br>程序，也能把二进制文件和依赖性预先加载到内存，以提供更快速的访<br>问。随着安装后的第一次重启，它会自动运行。<br>·BleachBit（apt-get install bleachbit）释放磁盘空间，通过释放缓<br>存、删除cookie、清除上网记录、粉碎临时文件、删除日志，以及丢弃<br>其他一些非必需的文件来提高隐私性。使用高级技术，包括粉碎文件来<br>防止恢复，擦除空闲磁盘空间来隐藏没有完全删除的文件的踪迹。</p><p>~/.config/deepin/deepin-terminal/config.conf</p><h3 id="执行命令">执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo apt-get update<br>sudo apt-get upgrade<br></code></pre></td></tr></table></figure><h2 id="配置VIM">配置VIM</h2><h3 id="打开终端，执行命令">打开终端，执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo gedit &#x2F;etc&#x2F;hosts<br></code></pre></td></tr></table></figure><h3 id="将以下两行文本添加到文本框中，保存并退出">将以下两行文本添加到文本框中，保存并退出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">192.30.255.112 github.com git<br>185.31.16.184 github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure><h3 id="执行命令-2">执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo wget -qO- https:&#x2F;&#x2F;raw.github.com&#x2F;ma6174&#x2F;vim&#x2F;master&#x2F;setup.sh | sh -x<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/LSG_Down/article/details/89319472">https://blog.csdn.net/LSG_Down/article/details/89319472</a></p><p><a href="https://www.jianshu.com/p/75cde8a80fd7">https://www.jianshu.com/p/75cde8a80fd7</a></p><h2 id="安装sshpi及scppi">安装sshpi及scppi</h2><p>sshpi.sh参考代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br><br>#文件名：sshpi.sh<br>#用途：远程连接树莓派<br><br>function Usage() &#123;<br>echo &quot;Usage: sshpi Username@pi&quot;<br>echo &quot;Like This：sshpi UserA@pi1&quot;<br>&#125;<br>if [[ ! $# -eq 1  ]]; then<br>Usage<br>exit<br>fi<br><br>echo $1 | grep &quot;@&quot; &gt;&#x2F;dev&#x2F;zero 2&gt;&amp;1<br><br>if [[ ! $? -eq 0 ]]; then<br>echo &quot;argument wrong！&quot;<br>Usage<br>exit<br>fi<br>Username&#x3D;&#96;echo $1 | cut -d &quot;@&quot; -f 1&#96;<br>if [[ $&#123;Username&#125;x &#x3D;&#x3D; x ]]; then<br>echo &quot;Please input your username!&quot;<br>Usage<br>exit<br>fi<br>Hostname&#x3D;&#96;echo $1 | cut -d &quot;@&quot; -f 2&#96;<br>if [[ $&#123;Hostname&#125;x &#x3D;&#x3D; x ]]; then<br>echo &quot;Please input Hostname of Pi!&quot;<br>Usage<br>exit<br>fi<br>echo $Hostname | grep -w &quot;^pi[1-9][0-9]\?&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<br>if [[ ! $? -eq 0 ]]; then<br>echo &quot;Hostname is Wrong!&quot;<br>Usage<br>exit<br>fi<br>HostNum&#x3D;&#96;echo $Hostname | cut -c 3-&#96;<br>if [[ $HostNum -gt 22 ]]; then<br>echo &quot;Hostname is Wrong!&quot;<br>Usage<br>exit<br>fi<br><br>port&#x3D;$[6530 + $HostNum]<br>echo -e &quot;\033[46;30m You Will login\033[0m\033[46;31m $Hostname\033[0m\033[46;30m with Username \033[46;31m$Username\033[0m\033[46;30m, enjoy it!\033[0m&quot;<br>ssh -p $port $&#123;Username&#125;@zentao.haizeix.tech<br></code></pre></td></tr></table></figure><p>scppi.sh参考代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br><br>#文件名：scppi.sh<br>#用途：远程拷贝文件，在树莓派和本机之间<br><br>function Usage() &#123;<br>echo &quot;Usage: scppi file_or_dir Username@piname:dest_file_or_dir&quot;<br>echo &quot;       scppi Username@piname:.&#x2F;file_or_dir  file_or_dir&quot;<br>echo &quot;Like This：scppi PiHealth pi@pi1:.&#x2F;new&quot;<br>&#125;<br>if [[ ! $# -eq 2  ]]; then<br>Usage<br>exit<br>fi<br>#1.源<br>#2.目标<br><br>echo $1 | grep -q &quot;@&quot;<br><br>if [[ $? -eq 0 ]]; then<br>remote&#x3D;$1<br>local&#x3D;$2<br>else<br>remote&#x3D;$2<br>local&#x3D;$1<br>fi<br><br>echo $remote | grep @ | grep : &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<br>if [[ ! $? -eq 0 ]]; then<br>echo &quot;argument wrong！&quot;<br>Usage<br>exit<br>fi<br>Username&#x3D;&#96;echo $remote | cut -d &quot;@&quot; -f 1&#96;<br>if [[ $&#123;Username&#125;x &#x3D;&#x3D; x ]]; then<br>echo &quot;Please input your username!&quot;<br>Usage<br>exit<br>fi<br>Hostname&#x3D;&#96;echo $remote | cut -d &quot;@&quot; -f 2 | cut -d &quot;:&quot; -f 1&#96;<br>if [[ $&#123;Hostname&#125;x &#x3D;&#x3D; x ]]; then<br>echo &quot;Please input Hostname of Pi!&quot;<br>Usage<br>exit<br>fi<br>echo $Hostname | grep -w &quot;^pi[1-9][0-9]\?&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<br>if [[ ! $? -eq 0 ]]; then<br>echo &quot;Hostname is Wrong!&quot;<br>Usage<br>exit<br>fi<br>dir_file&#x3D;&#96;echo $remote | cut -d &quot;@&quot; -f 2 | cut -d &quot;:&quot; -f 2&#96;<br>if [[ $&#123;dir_file&#125;x &#x3D;&#x3D; x ]]; then<br>echo &quot;Please input dest_file_or_dir of Pi!&quot;<br>Usage<br>exit<br>fi<br><br>HostNum&#x3D;&#96;echo $Hostname | cut -c 3-&#96;<br><br>if [[ $HostNum -gt 22 ]]; then<br>echo &quot;Hostname is Wrong!&quot;<br>Usage<br>exit<br>fi<br><br>port&#x3D;$[6530 + $HostNum]<br>echo -e &quot;\033[46;30m Coping \033[46;31m$1\033[46;30m to \033[46;31m$dir_file\033[46;30m on \033[46;31m$Hostname\033[46;30m with Username \033[46;31m$Username\033[46;30m, enjoy it!\033[0m&quot;<br><br>if [[ $1 &#x3D; $local ]]; then<br>scp -P $port -r $1  $&#123;Username&#125;@zentao.haizeix.tech:$dir_file<br>else<br>scp -P $port -r $&#123;Username&#125;@zentao.haizeix.tech:$dir_file $local<br>fi<br></code></pre></td></tr></table></figure><h3 id="打开终端，执行命令-2">打开终端，执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">vim sshpi.sh<br></code></pre></td></tr></table></figure><h3 id="在VIM文本框里粘贴sshpi脚本的代码，保存并退出（：wq）">在VIM文本框里粘贴sshpi脚本的代码，保存并退出（：wq）</h3><h3 id="将sshpi-sh重命名为sshpi-赋予sshpi脚本可执行权限">将sshpi.sh重命名为sshpi,赋予sshpi脚本可执行权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">mv sshpi.sh sshpi<br>chmod a+x sshpi<br></code></pre></td></tr></table></figure><h3 id="执行命令-3">执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">echo $PATH<br></code></pre></td></tr></table></figure><h3 id="将sshpi复制到PATH路径下">将sshpi复制到PATH路径下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cp sshpi &#x2F;bin<br></code></pre></td></tr></table></figure><h3 id="同样的操作生成scppi脚本">同样的操作生成scppi脚本</h3><h1>DAY02</h1><h2 id="设置免密登录">设置免密登录</h2><h3 id="打开终端，执行命令-3">打开终端，执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sshpi lws@pi3<br></code></pre></td></tr></table></figure><p>暂时需要密码（haizei）来连接树莓派</p><h3 id="在本机生成秘钥">在本机生成秘钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ssh-keygen<br></code></pre></td></tr></table></figure><h3 id="将秘钥复制到authorized-keys文件中">将秘钥复制到authorized_keys文件中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cat .ssh&#x2F;id_rsa.pub&gt;&gt;.ssh&#x2F;authorized_keys<br></code></pre></td></tr></table></figure><h3 id="将本机的authorized-keys文件复制到树莓派中">将本机的authorized_keys文件复制到树莓派中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">scppi .ssh&#x2F;authorized_keys lws@pi3:&#x2F;.ssh<br></code></pre></td></tr></table></figure><h3 id="再次连接树莓派，验证是否成功">再次连接树莓派，验证是否成功</h3><p>check.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include &lt;stdio.h&gt;<br>#include &lt;sys&#x2F;socket.h&gt;<br>#include &lt;sys&#x2F;types.h&gt;<br>#include &lt;arpa&#x2F;inet.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;pwd.h&gt;<br><br>int socket_connect(int port, char *host) &#123;<br>int sockfd;<br>struct sockaddr_in dest_addr;<br>if ((sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123;<br>perror(&quot;socket() error&quot;);<br>return -1;<br>&#125;<br><br>memset(&amp;dest_addr, 0, sizeof(dest_addr));<br>dest_addr.sin_family &#x3D; AF_INET;<br>dest_addr.sin_port &#x3D; htons(port);<br>dest_addr.sin_addr.s_addr &#x3D; inet_addr(host);<br><br>if (connect(sockfd, (struct sockaddr *)&amp;dest_addr, sizeof(dest_addr)) &lt; 0) &#123;<br>perror(&quot;connect() error&quot;);<br>return -1;<br>&#125;<br>return sockfd;<br><br>&#125;<br><br>int main() &#123;<br>int  socket_fd;<br>struct passwd *pwd;<br>pwd &#x3D; getpwuid(getuid());<br>char ip_addr[20] &#x3D; &quot;192.168.1.40&quot;;<br>int port &#x3D; 8888;<br>char username[20] &#x3D; &#123;0&#125;;<br>strcpy(username, pwd-&gt;pw_name);<br>socket_fd &#x3D; socket_connect(port, ip_addr);<br>if (socket_fd &lt; 0)<br>&#123;<br>exit(1);<br>&#125;<br>if (send(socket_fd, username, strlen(username), 0) &gt; 0) &#123;<br>printf(&quot;Check Success\n&quot;);<br>&#125; <br>close(socket_fd);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>gcc check.c -o check</p><h2 id="VIM的简单使用">VIM的简单使用</h2><p><img src="https://ese3a9b6c5d0ic.prissl.qiqiuyun.net/course-activity-272/20190411093248-lntidnybu9wksckc/53eb89158008bece_img3?e=1563481633&amp;token=ExRD5wolmUnwwITVeSEXDQXizfxTRp7vnaMKJbO-:CAFs0zlzq99uvJ2s6B6SYjVIbcI=" alt="img"></p><h3 id="VIM的四种模式">VIM的四种模式</h3><h3 id="普通模式">普通模式</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x d dd ndd dw d$ d^ dG dnG</td><td>删除说明</td></tr><tr><td>y yy yG ynG y$ y^</td><td>复制</td></tr><tr><td>p P</td><td>粘贴</td></tr><tr><td>gg GG ngg</td><td>移动光标</td></tr><tr><td>R cc cG cnG c$ c^</td><td>替换</td></tr><tr><td>u ctrl+r ctrl+v</td><td>undo redo 可视块操作</td></tr></tbody></table><h3 id="插入模式">插入模式</h3><table><thead><tr><th>i</th><th>在光标之前追加</th></tr></thead><tbody><tr><td>a</td><td>在光标之后追加</td></tr><tr><td>A</td><td>在一行的结尾处追加</td></tr><tr><td>I</td><td>在一行的开头处插入</td></tr><tr><td>o</td><td>在光标所在位置的下一行打开新行插入</td></tr><tr><td>O</td><td>在光标所在位置的上一行打开新行插入</td></tr></tbody></table><h3 id="命令模式">命令模式</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:w :q :wq :x :wq! :q!</td><td>文件的保存与退出操作</td></tr><tr><td>:args</td><td>显示文件名称，切换文件</td></tr><tr><td>:e foo.txt</td><td>打开foo.txt</td></tr><tr><td>:saveas ~/foo.txt</td><td>另存为~/foo.txt</td></tr><tr><td>:split :vsplit</td><td>切分窗口</td></tr><tr><td>:set</td><td>设置选项</td></tr></tbody></table><h3 id="其他使用技巧">其他使用技巧</h3><table><thead><tr><th>Ctrl+z</th><th>挂起</th></tr></thead><tbody><tr><td>fg</td><td>返回前台</td></tr><tr><td>/findstring</td><td>查找</td></tr></tbody></table><h2 id="Python的升级与tldr的升级">Python的升级与tldr的升级</h2><h3 id="打开终端，执行命令-4">打开终端，执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo apt-get install python<br>sudo apt-get install python3<br></code></pre></td></tr></table></figure><h3 id="查看Python版本">查看Python版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">python -V<br>python3 -V<br></code></pre></td></tr></table></figure><h3 id="获取Python路径">获取Python路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">which python<br></code></pre></td></tr></table></figure><h3 id="查看Python">查看Python</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ls -al &#x2F;usr&#x2F;bin&#x2F;python<br></code></pre></td></tr></table></figure><h3 id="强制删除Python，将Python3-5指向Python">强制删除Python，将Python3.5指向Python</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo rm &#x2F;usr&#x2F;bin&#x2F;python<br>sudo ln &#x2F;usr&#x2F;bin&#x2F;python3.5 &#x2F;usr&#x2F;bin&#x2F;python<br></code></pre></td></tr></table></figure><h3 id="安装pyhton3-pip">安装pyhton3-pip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo apt-get insatll python3-pip<br></code></pre></td></tr></table></figure><h3 id="升级pip">升级pip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">pip install --upgrade pip<br></code></pre></td></tr></table></figure><h3 id="pip3-list报错，解决">pip3 list报错，解决</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo vim &#x2F;usr&#x2F;bin&#x2F;pip3<br></code></pre></td></tr></table></figure><p>在文本框中pip后加上._internal</p><h3 id="安装tldr">安装tldr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo pip install tldr<br></code></pre></td></tr></table></figure><h2 id="Linux极简入门">Linux极简入门</h2><h3 id="软件的安装与卸载">软件的安装与卸载</h3><ul><li>apt-get update</li><li>apt-get upgrade</li><li>apt-get install xxx</li><li>apt-get --purge remove xxx</li><li>apt-cache search xxx</li></ul><h3 id="目录">目录</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cd</td><td>切换当前目录</td></tr><tr><td>pwd</td><td>打印当期目录工作</td></tr><tr><td>mkdir</td><td>创建目录</td></tr></tbody></table><h3 id="cd切换工作">cd切换工作</h3><ul><li><p>cd /etc直接切换到/etc目录</p><p>cd …切换到上层目录</p><p>cd .切换到当前目录</p><p>cd回到自己的家目录</p><p>cd ~回到自己的家目录</p><p>cd -回到上次工作目录</p></li></ul><h3 id="pwd打印当前工作目录">pwd打印当前工作目录</h3><p>pwd [-LP]</p><ul><li>-L显示逻辑工作目录<br>-P显示物理工作目录</li></ul><h3 id="mkdir创建目录">mkdir创建目录</h3><p>mkdir [-pm] <dir></p><ul><li><p>-p自动创建父目录</p><p>-m设置权限</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DAY01&lt;/h1&gt;
&lt;h2 id=&quot;更新源&quot;&gt;更新源&lt;/h2&gt;
&lt;h3 id=&quot;打开终端（Ctrl-Alt-T），执行命令&quot;&gt;打开终端（Ctrl+Alt+T），执行命令&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Newcoder_cpp</title>
    <link href="https://lwscode.com/p/22684/"/>
    <id>https://lwscode.com/p/22684/</id>
    <published>2021-04-20T02:58:13.000Z</published>
    <updated>2021-04-26T11:15:10.711Z</updated>
    
    <content type="html"><![CDATA[<h1>niuke interview</h1><h2 id="基本语言">基本语言</h2><h3 id="请说一下C-C-中指针和引用的区别？">请说一下C/C++ 中指针和引用的区别？</h3><p>参考回答：</p><ol><li><p>指针有自己的一块空间，而引用只是一个别名；</p></li><li><p>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p></li><li><p>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</p></li><li><p>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</p></li><li><p>可以有const指针，但是没有const引用；</p></li><li><p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p></li><li><p>指针可以有多级指针（**p），而引用至于一级；</p></li><li><p>指针和引用使用++运算符的意义不一样；</p></li><li><p>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p></li></ol><h3 id="请你回答一下野指针是什么？">请你回答一下野指针是什么？</h3><p>参考回答：</p><p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;niuke interview&lt;/h1&gt;
&lt;h2 id=&quot;基本语言&quot;&gt;基本语言&lt;/h2&gt;
&lt;h3 id=&quot;请说一下C-C-中指针和引用的区别？&quot;&gt;请说一下C/C++ 中指针和引用的区别？&lt;/h3&gt;
&lt;p&gt;参考回答：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;指针有自己的一块空间，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Manjaro Kde安装后的配置</title>
    <link href="https://lwscode.com/p/9628/"/>
    <id>https://lwscode.com/p/9628/</id>
    <published>2021-04-20T02:55:45.000Z</published>
    <updated>2021-04-26T11:15:10.711Z</updated>
    
    <content type="html"><![CDATA[<h1>manjaro kde安装后的配置</h1><h2 id="启动项">启动项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-grub<br></code></pre></td></tr></table></figure><h2 id="镜像源（选择清华源）">镜像源（选择清华源）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman-mirrors -i -c China -m rank<br>sudo pacman -Syy<br>sudo nano /etc/pacman.conf<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">[archlinuxcn]<br>SigLevel &#x3D; Optional TrustedOnly<br>Server &#x3D; http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;archlinuxcn&#x2F;$arch<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S archlinuxcn-keyring<br>sudo apcman -Syyu<br></code></pre></td></tr></table></figure><h2 id="安装软件">安装软件</h2><h3 id="yay">yay</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S yay base-devel<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay --save --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot;<br></code></pre></td></tr></table></figure><h3 id="git">git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S git<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &#x27;lws597&#x27;<br>git config --global user.email &#x27;1320949958@qq.com&#x27;<br>sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">52.74.223.119 github.com<br>151.101.77.194 github.global.ssl.fastly.net<br>151.101.76.133 raw.githubusercontent.com<br></code></pre></td></tr></table></figure><h4 id="github密钥导入">github密钥导入</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen<br>cat .ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><h3 id="常用">常用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S gcc go jdk8-openjdk clang python python2 google-chrome netease-cloud-music typora<br></code></pre></td></tr></table></figure><h3 id="pip">pip</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S python-pip python2-pip<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/.pip<br>nano ~/.pip/pip.conf<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">[global]<br>index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple<br>[install]<br>trusted-host &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn<br></code></pre></td></tr></table></figure><h3 id="npm">npm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config set registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h3 id="neovim">neovim</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -Rns vim<br>yay -S neovim<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd .config<br>git clone git://github.com/lws597/nvim<br></code></pre></td></tr></table></figure><h3 id="zsh">zsh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S zsh<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;<br></code></pre></td></tr></table></figure><h4 id="zsh插件">zsh插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">plugins&#x3D;(git zsh-autosuggestions zsh-syntax-highlighting autojump web-search extract last-working-dir sudo pip thefuck colored-man-pages colorize safe-paste git-open vi-mode copyfile copydir gitfast command-not-found history)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S autojump thefuck<br>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting<br>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions<br>git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open<br></code></pre></td></tr></table></figure><h4 id="zshrc添加">zshrc添加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">alias vim&#x3D;&quot;nvim&quot;<br>alias vi&#x3D;&quot;nvim&quot;<br>alias rm&#x3D;&quot;rm -i&quot;<br>alias cp&#x3D;&quot;cp -i&quot;<br>alias cls&#x3D;&quot;clear&quot;<br>alias cat&#x3D;&quot;ccat&quot;<br>alias ra&#x3D;&quot;ranger&quot;<br>alias -s c&#x3D;copyfile<br>alias -s cpp&#x3D;copyfile<br></code></pre></td></tr></table></figure><h3 id="输入法（rime）">输入法（rime）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S fcitx-im kcm-fcitx fcitx-rime<br>sudo vim ~/.xprofile<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">export GTK_IM_MODULE&#x3D;fcitx<br>export QT_IM_MODULE&#x3D;fcitx<br>export XMODIFIERS&#x3D;&quot;&quot;@im&#x3D;fcitx&quot;<br></code></pre></td></tr></table></figure><h3 id="wps">wps</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S wps-office-mui-zh-cn wps-office ttf-wps-fonts<br></code></pre></td></tr></table></figure><h3 id="IDE">IDE</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S visual-studio-code-bin<br></code></pre></td></tr></table></figure><h3 id="字体">字体</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S nerd-fonts-complete ttf-monaco ttf-hanazono<br></code></pre></td></tr></table></figure><h3 id="美化">美化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S latte-dock<br></code></pre></td></tr></table></figure><p>主题arc</p><p>图标numix papirus</p><p>光标mcmojave</p><h3 id="其他软件">其他软件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S xmind zoom dingtalk electronic-wechat qq-linux<br></code></pre></td></tr></table></figure><h3 id="双系统时间">双系统时间</h3><p>windows端管理员下cmd或powershell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">reg add &quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_QWORD /f<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;manjaro kde安装后的配置&lt;/h1&gt;
&lt;h2 id=&quot;启动项&quot;&gt;启动项&lt;/h2&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git代理</title>
    <link href="https://lwscode.com/p/39017/"/>
    <id>https://lwscode.com/p/39017/</id>
    <published>2021-04-20T02:54:04.000Z</published>
    <updated>2021-04-26T11:15:10.710Z</updated>
    
    <content type="html"><![CDATA[<h1>git设置和取消代理</h1><h2 id="设置如下：">设置如下：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global https.proxy http://127.0.0.1:1080<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global https.proxy https://127.0.0.1:1080<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span> <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global https.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="取消">取消</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;git设置和取消代理&lt;/h1&gt;
&lt;h2 id=&quot;设置如下：&quot;&gt;设置如下：&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Effective</title>
    <link href="https://lwscode.com/p/52590/"/>
    <id>https://lwscode.com/p/52590/</id>
    <published>2021-04-20T02:50:31.000Z</published>
    <updated>2021-04-26T11:15:10.710Z</updated>
    
    <content type="html"><![CDATA[<h1>Interview Q&amp;A</h1><h2 id="Effective-C">Effective C++</h2><ol><li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</li><li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</li><li>尽可能使用 const</li><li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</li><li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）</li><li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）</li><li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）</li><li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）</li><li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）</li><li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）</li><li>在 <code>operator=</code> 中处理 “自我赋值”</li><li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）</li><li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））</li><li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））</li><li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）</li><li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）</li><li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）</li><li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）</li><li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。</li><li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）</li><li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）</li><li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）</li><li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</li><li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数</li><li>考虑写一个不抛异常的 swap 函数</li><li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）</li><li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&lt;T&gt;(expression)</code>、<code>dynamic_cast&lt;T&gt;(expression)</code>、<code>reinterpret_cast&lt;T&gt;(expression)</code>、<code>static_cast&lt;T&gt;(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）</li><li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）</li><li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）</li><li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）</li><li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）</li><li>确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）</li><li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）</li><li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）</li><li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）</li><li>绝不重新定义继承而来的 non-virtual 函数</li><li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）</li><li>通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））</li><li>明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）</li><li>明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）</li><li>了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）</li><li>了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）</li><li>学习处理模板化基类内的名称（可在 derived class templates 内通过 <code>this-&gt;</code> 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）</li><li>将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）</li><li>运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）</li><li>需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）</li><li>请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if…else 测试）</li><li>认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）</li><li>了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）</li><li>了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）</li><li>编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）</li><li>写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）</li><li>不要轻忽编译器的警告</li><li>让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）</li><li>让自己熟悉 Boost（准标准库）</li></ol><h2 id="More-Effective-c">More Effective c++</h2><ol><li>仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）</li><li>最好使用 C++ 转型操作符（<code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>）</li><li>绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）</li><li>非必要不提供 default constructor（避免对象中的字段被无意义地初始化）</li><li>对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）</li><li>区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）</li><li>千万不要重载 <code>&amp;&amp;</code>，<code>||</code> 和 <code>,</code> 操作符（<code>&amp;&amp;</code> 与 <code>||</code> 的重载会用 “函数调用语义” 取代 “骤死式语义”；<code>,</code> 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）</li><li>了解各种不同意义的 new 和 delete（<code>new operator</code>、<code>operator new</code>、<code>placement new</code>、<code>operator new[]</code>；<code>delete operator</code>、<code>operator delete</code>、<code>destructor</code>、<code>operator delete[]</code>）</li><li>利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）</li><li>在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try…catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）</li><li>禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）</li><li>了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）</li><li>以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）</li><li>明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）</li><li>了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）</li><li>谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）</li><li>考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）</li><li>分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Interview Q&amp;amp;A&lt;/h1&gt;
&lt;h2 id=&quot;Effective-C&quot;&gt;Effective C++&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）&lt;/li&gt;
&lt;li&gt;宁</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cpp_stl</title>
    <link href="https://lwscode.com/p/56828/"/>
    <id>https://lwscode.com/p/56828/</id>
    <published>2021-04-20T02:48:16.000Z</published>
    <updated>2021-04-26T11:15:10.710Z</updated>
    
    <content type="html"><![CDATA[<h1>c++ stl</h1><h2 id="queue-类说明">queue-类说明</h2><p>queue类：队列</p><ul><li>头文件：queue</li><li>命名空间：std</li><li>声明：queue&lt;data_type&gt; q;</li></ul><table><thead><tr><th style="text-align:left">q.fornt()</th><th>查看队首元素</th></tr></thead><tbody><tr><td style="text-align:left">q.empty()</td><td>队列判空</td></tr><tr><td style="text-align:left">q.push()</td><td>入队</td></tr><tr><td style="text-align:left">q.pop()</td><td>出队</td></tr><tr><td style="text-align:left">q.size()</td><td>队列元素数量</td></tr></tbody></table><h2 id="stack-类说明">stack-类说明</h2><p>stack类：栈</p><ul><li>头文件：stack</li><li>命名空间：std</li><li>声明：stack&lt;data_type&gt; s;</li></ul><table><thead><tr><th>s.top()</th><th>查看栈顶元素</th></tr></thead><tbody><tr><td>s.empty()</td><td>栈判空</td></tr><tr><td>s.push()</td><td>入栈</td></tr><tr><td>s.pop()类</td><td>出栈</td></tr><tr><td>s.size()</td><td>栈元素数量</td></tr></tbody></table><h2 id="string-类说明">string-类说明</h2><p>string类：字符串</p><ul><li>头文件：string</li><li>命名空间：std</li><li>声明：string str1, str2;</li></ul><table><thead><tr><th>str1 == str2</th><th>字符串判等</th></tr></thead><tbody><tr><td>str1 &lt; str2</td><td>字典序小于</td></tr><tr><td>str1 &gt; str2</td><td>字典序大于</td></tr><tr><td>str1 += str2</td><td>字符串连接</td></tr><tr><td>str1.length()</td><td>字符串长度</td></tr></tbody></table><h3 id="string-hzoj-166">string (hzoj-166)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str1, str2;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; str1 &gt;&gt; n &gt;&gt; str2;<br>    cout &lt;&lt; <span class="hljs-built_in">min</span>(str1.<span class="hljs-built_in">length</span>(), (<span class="hljs-keyword">size_t</span>)<span class="hljs-number">100</span>) &lt;&lt; endl;<br>    str1.<span class="hljs-built_in">insert</span>(n - <span class="hljs-number">1</span>, str2);<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; str1.<span class="hljs-built_in">length</span>() - str1.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&#x27;x&#x27;</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hash-map-类说明">hash_map-类说明</h2><p>hash_map类：字符串</p><ul><li>头文件：&lt;hash_map&gt; / &lt;ext/hash_map&gt;</li><li>命名空间：__gnu_cxx</li><li>声明：hash_map&lt;key_type, value_type, hash_func&gt; h;</li></ul><table><thead><tr><th>h.find(key)</th><th>判断某个key值是否在hash_map中</th></tr></thead><tbody><tr><td>h[key] = value</td><td>将value存储在key位上</td></tr><tr><td>h[key]</td><td>房屋key值对应的value</td></tr><tr><td>h.begin()</td><td>哈希表的起始位置</td></tr><tr><td>h.end()</td><td>哈希表的结束位置</td></tr></tbody></table><h2 id="unordered-map-类说明（c-11标准）">unordered_map-类说明（c++11标准）</h2><p>unordered_map-类：字符串</p><ul><li>头文件：unordered_map</li><li>命名空间：std</li><li>声明：unordered_map&lt;key_type, value_type, hash_func&gt; h;</li></ul><table><thead><tr><th>h.find(key)</th><th>判断某个key值是否在unordered_map中</th></tr></thead><tbody><tr><td>h[key] = value</td><td>将value存储在key位上</td></tr><tr><td>h[key]</td><td>访问key值对应的value</td></tr><tr><td>h.begin()</td><td>哈希表的起始位置</td></tr><tr><td>h.end()</td><td>哈希表的结束位置</td></tr></tbody></table><h3 id="sort-hzoj-245">sort (hzoj-245)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 100000</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> a[max_n + <span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a, a + n);<br>    <span class="hljs-keyword">int</span> p = a[n &gt;&gt; <span class="hljs-number">1</span>], ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        ans += <span class="hljs-built_in">abs</span>(p - a[i]);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="nth-element-hzoj-245">nth_element (hzoj-245)</h3><p>nth_element是部分排序算法，它重排[first, last)中元素，使得：</p><ul><li>nth所指向的元素被更改为假如[first, last)已排序则该位置会出现的元素。</li><li>这个新的nth元素前的所有元素小于或等于新的 nth 元素后的所有元素。</li></ul><p>更正式而言，nth_element以升序部分排序范围[first, last)，使得对于任何范围[first, nth)中的i和任何范围[nth, last)中的j，都满足条件!(*j &lt; i)。置于nth位置的元素则准确地是假如完全排序范围则应出现于此位置的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 100000</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> a[max_n + <span class="hljs-number">5</span>], ind[max_n + <span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">nth_element</span>(a, a + (n &gt;&gt; <span class="hljs-number">1</span>), a + n);<br>    <span class="hljs-keyword">int</span> p = a[n &gt;&gt; <span class="hljs-number">1</span>], ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        ans += <span class="hljs-built_in">abs</span>(p - a[i]);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map">map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string name;<br>    <span class="hljs-keyword">int</span> n, age;<br>    set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    cout &lt;&lt; *s.<span class="hljs-built_in">begin</span>() &lt;&lt; endl;<br>    s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = s.<span class="hljs-built_in">begin</span>(); iter != s.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>        cout &lt;&lt; *iter &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    map&lt;<span class="hljs-keyword">int</span>, string&gt; arr;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; age &gt;&gt; name;<br>        arr[age] = name;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = arr.<span class="hljs-built_in">begin</span>(); iter != arr.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>        cout &lt;&lt; iter-&gt;second &lt;&lt; endl; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="存储任意类型的数组-vector-array">存储任意类型的数组 (vector-&gt;array)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> &#123;</span><br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-built_in">Array</span>() &#123;<br>        <span class="hljs-keyword">this</span>-&gt;__size = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">this</span>-&gt;__cnt  = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>-&gt;data = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;__size];<br>    &#125;<br>    <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;__size = <span class="hljs-number">2</span> * n;<br>        <span class="hljs-keyword">this</span>-&gt;__cnt  = n;<br>        <span class="hljs-keyword">this</span>-&gt;data = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;__size];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;a)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span>(<span class="hljs-keyword">this</span>-&gt;data + ((<span class="hljs-keyword">this</span>-&gt;__cnt)++)) <span class="hljs-built_in">T</span>(a);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;__cnt;<br>    &#125;<br>    T &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> ind) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;data[ind];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T *data;<br>    <span class="hljs-keyword">int</span> __size, __cnt;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Array&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cout &lt;&lt; arr.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">123</span>);<br>    cout &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    cout &lt;&lt; arr.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <br>    cout &lt;&lt; arr2.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    arr2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">123</span>);<br>    cout &lt;&lt; arr2[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    cout &lt;&lt; arr2.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;c++ stl&lt;/h1&gt;
&lt;h2 id=&quot;queue-类说明&quot;&gt;queue-类说明&lt;/h2&gt;
&lt;p&gt;queue类：队列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头文件：queue&lt;/li&gt;
&lt;li&gt;命名空间：std&lt;/li&gt;
&lt;li&gt;声明：queue&amp;lt;data_type&amp;gt; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Computer_networking</title>
    <link href="https://lwscode.com/p/40772/"/>
    <id>https://lwscode.com/p/40772/</id>
    <published>2021-04-20T02:46:58.000Z</published>
    <updated>2021-04-26T11:15:10.709Z</updated>
    
    <content type="html"><![CDATA[<h1>Interview Q&amp;A Computer Networking</h1><h2 id="数据链路层">数据链路层</h2><h3 id="广播信道">广播信道</h3><p>广播通信：</p><ul><li>硬件地址（物理地址、MAC 地址）</li><li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li><li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li><li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li></ul><h2 id="运输层">运输层</h2><h3 id="为什么客户端释放最后需要-TIME-WAIT-等待-2MSL-呢？">为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？</h3><ol><li>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li><li>防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Interview Q&amp;amp;A Computer Networking&lt;/h1&gt;
&lt;h2 id=&quot;数据链路层&quot;&gt;数据链路层&lt;/h2&gt;
&lt;h3 id=&quot;广播信道&quot;&gt;广播信道&lt;/h3&gt;
&lt;p&gt;广播通信：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件地址（物理地址、MAC 地址）&lt;/li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C/cpp</title>
    <link href="https://lwscode.com/p/8601/"/>
    <id>https://lwscode.com/p/8601/</id>
    <published>2021-04-20T02:45:39.000Z</published>
    <updated>2021-04-26T11:15:10.709Z</updated>
    
    <content type="html"><![CDATA[<h1>Interview Q&amp;A C/CPP</h1><h2 id="const">const</h2><p>int getValue();             // 普通成员函数</p><p>? int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值</p><p>const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变)</p><p>char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变)</p><p>? const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量</p><h2 id="pragma-pack-n">#pragma pack(n)</h2><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p><p>#pragma pack(n) 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(push)  <span class="hljs-comment">// 保存对齐状态</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(4)     <span class="hljs-comment">// 设定为 4 字节对齐</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> m1;<br>    <span class="hljs-keyword">double</span> m4;<br>    <span class="hljs-keyword">int</span> m3;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(pop)   <span class="hljs-comment">// 恢复对齐状态</span></span><br></code></pre></td></tr></table></figure><h2 id="位域">位域</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Bit mode: <span class="hljs-number">2</span>;    <span class="hljs-comment">// mode 占 2 位</span><br></code></pre></td></tr></table></figure><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li></ul><h2 id="explicit（显式）关键字">explicit（显式）关键字</h2><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外</li></ul><p>explicit 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span>) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doA</span><span class="hljs-params">(A a)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doB</span><span class="hljs-params">(B b)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;        <span class="hljs-comment">// OK：直接初始化</span><br>    A a2 = <span class="hljs-number">1</span>;        <span class="hljs-comment">// OK：复制初始化</span><br>    A a3&#123; <span class="hljs-number">1</span> &#125;;        <span class="hljs-comment">// OK：直接列表初始化</span><br>    A a4 = &#123; <span class="hljs-number">1</span> &#125;;        <span class="hljs-comment">// OK：复制列表初始化</span><br>    A a5 = (A)<span class="hljs-number">1</span>;        <span class="hljs-comment">// OK：允许 static_cast 的显式转换 </span><br>    <span class="hljs-built_in">doA</span>(<span class="hljs-number">1</span>);            <span class="hljs-comment">// OK：允许从 int 到 A 的隐式转换</span><br>    <span class="hljs-keyword">if</span> (a1);        <span class="hljs-comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span><br>    <span class="hljs-keyword">bool</span> a6（a1）;        <span class="hljs-comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span><br>    <span class="hljs-keyword">bool</span> a7 = a1;        <span class="hljs-comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span><br>    <span class="hljs-keyword">bool</span> a8 = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">bool</span>&gt;(a1);  <span class="hljs-comment">// OK ：static_cast 进行直接初始化</span><br><br>    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;        <span class="hljs-comment">// OK：直接初始化</span><br>    B b2 = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span><br>    B b3&#123; <span class="hljs-number">1</span> &#125;;        <span class="hljs-comment">// OK：直接列表初始化</span><br>    B b4 = &#123; <span class="hljs-number">1</span> &#125;;        <span class="hljs-comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span><br>    B b5 = (B)<span class="hljs-number">1</span>;        <span class="hljs-comment">// OK：允许 static_cast 的显式转换</span><br>    <span class="hljs-built_in">doB</span>(<span class="hljs-number">1</span>);            <span class="hljs-comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span><br>    <span class="hljs-keyword">if</span> (b1);        <span class="hljs-comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">b6</span><span class="hljs-params">(b1)</span></span>;        <span class="hljs-comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span><br>    <span class="hljs-keyword">bool</span> b7 = b1;        <span class="hljs-comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span><br>    <span class="hljs-keyword">bool</span> b8 = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">bool</span>&gt;(b1);  <span class="hljs-comment">// OK：static_cast 进行直接初始化</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-实现-C-类decltype">C 实现 C++ 类decltype</h2><p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p><ul><li>封装：使用函数指针把属性与方法封装到结构体中</li><li>继承：结构体嵌套</li><li>多态：父类与子类方法的函数指针不同</li></ul><h2 id="构造函数的-using-声明">构造函数的 using 声明</h2><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::Base;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Derived</span>(parms) : <span class="hljs-built_in">Base</span>(args) &#123; &#125;<br></code></pre></td></tr></table></figure><h2 id="enum-枚举类型">enum 枚举类型</h2><h3 id="限定作用域的枚举类型">限定作用域的枚举类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">open_modes</span> &#123;</span> input, output, append &#125;;<br></code></pre></td></tr></table></figure><h3 id="不限定作用域的枚举类型">不限定作用域的枚举类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">color</span> &#123;</span> red, yellow, green &#125;;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> floatPrec = <span class="hljs-number">6</span>, doublePrec = <span class="hljs-number">10</span> &#125;;<br></code></pre></td></tr></table></figure><h2 id="decltype">decltype</h2><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span> ( expression )<br></code></pre></td></tr></table></figure><p>decltype 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 尾置返回允许我们在参数列表之后声明返回类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br>auto fcn(It beg, It end) -&gt; decltype(*beg)<br>&#123;<br>    <span class="hljs-comment">// 处理序列</span><br>    <span class="hljs-keyword">return</span> *beg;    <span class="hljs-comment">// 返回序列中一个元素的引用</span><br>&#125;<br><span class="hljs-comment">// 为了使用模板参数成员，必须用 typename</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br>auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type<br>&#123;<br>    <span class="hljs-comment">// 处理序列</span><br>    <span class="hljs-keyword">return</span> *beg;    <span class="hljs-comment">// 返回序列中一个元素的拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用折叠">引用折叠</h2><ul><li>X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp;</li><li>X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp;</li></ul><h2 id="initializer-list-列表初始化">initializer_list 列表初始化</h2><p>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数.</p><p>initializer_list 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;initializer_list&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> &#123;</span><br>    std::vector&lt;T&gt; v;<br>    <span class="hljs-built_in">S</span>(std::initializer_list&lt;T&gt; l) : <span class="hljs-built_in">v</span>(l) &#123;<br>         std::cout &lt;&lt; <span class="hljs-string">&quot;constructed with a &quot;</span> &lt;&lt; l.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;-element list\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(std::initializer_list&lt;T&gt; l)</span> </span>&#123;<br>        v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">end</span>(), l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    std::pair&lt;const T*, std::size_t&gt; c_arr() const &#123;<br>        <span class="hljs-keyword">return</span> &#123;&amp;v[<span class="hljs-number">0</span>], v.<span class="hljs-built_in">size</span>()&#125;;  <span class="hljs-comment">// 在 return 语句中复制列表初始化</span><br>                                   <span class="hljs-comment">// 这不使用 std::initializer_list</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">templated_fn</span><span class="hljs-params">(T)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    S&lt;<span class="hljs-keyword">int</span>&gt; s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 复制初始化</span><br>    s.<span class="hljs-built_in">append</span>(&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;);      <span class="hljs-comment">// 函数调用中的列表初始化</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The vector size is now &quot;</span> &lt;&lt; s.<span class="hljs-built_in">c_arr</span>().second &lt;&lt; <span class="hljs-string">&quot; ints:\n&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : s.v)<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Range-for over brace-init-list: \n&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-3</span>&#125;) <span class="hljs-comment">// auto 的规则令此带范围 for 工作</span><br>        std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">auto</span> al = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;   <span class="hljs-comment">// auto 的特殊规则</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The list bound to auto has size() = &quot;</span> &lt;&lt; al.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br><span class="hljs-comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span><br>                             <span class="hljs-comment">// 它无类型，故 T 无法推导</span><br>    templated_fn&lt;std::initializer_list&lt;<span class="hljs-keyword">int</span>&gt;&gt;(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;); <span class="hljs-comment">// OK</span><br>    templated_fn&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);           <span class="hljs-comment">// 也 OK</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定位-new">定位 new</h2><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">new</span> (place_address) type<br><span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (place_address) <span class="hljs-built_in">type</span> (initializers)<br><span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (place_address) type [size]<br><span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (place_address) type [size] &#123; braced initializer list &#125;<br></code></pre></td></tr></table></figure><ul><li><code>place_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul><h2 id="运行时类型信息-RTTI">运行时类型信息 (RTTI)</h2><h3 id="dynamic-cast">dynamic_cast</h3><ul><li>用于多态类型的转换</li></ul><h3 id="typeid">typeid</h3><ul><li>typeid 运算符允许在运行时确定对象的类型</li><li>type_id 返回一个 type_info 对象的引用</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li><li>只能获取对象的实际类型</li></ul><h3 id="type-info">type_info</h3><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li><li>头文件：typeinfo</li></ul><p>typeid、type_info 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flyable</span>                       // 能飞的</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeoff</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 起飞</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-comment">// 降落</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span> :</span> <span class="hljs-keyword">public</span> Flyable         <span class="hljs-comment">// 鸟</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foraging</span><span class="hljs-params">()</span> </span>&#123;...&#125;           <span class="hljs-comment">// 觅食</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeoff</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Bird</span>()&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plane</span> :</span> <span class="hljs-keyword">public</span> Flyable        <span class="hljs-comment">// 飞机</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">carry</span><span class="hljs-params">()</span> </span>&#123;...&#125;              <span class="hljs-comment">// 运输</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeoff</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type_info</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-keyword">const</span> type_info &amp; rhs) <span class="hljs-keyword">const</span>;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-keyword">const</span> type_info &amp; rhs) <span class="hljs-keyword">const</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">before</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_info &amp; rhs)</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">type_info</span>();<br><span class="hljs-keyword">private</span>:<br>    ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(Flyable *obj)</span>                 <span class="hljs-comment">// 做些事情</span></span><br><span class="hljs-function"></span>&#123;<br>    obj-&gt;<span class="hljs-built_in">takeoff</span>();<br><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(*obj).<span class="hljs-built_in">name</span>() &lt;&lt; endl;        <span class="hljs-comment">// 输出传入对象类型（&quot;class Bird&quot; or &quot;class Plane&quot;）</span><br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(*obj) == <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(Bird))            <span class="hljs-comment">// 判断对象类型</span><br>    &#123;<br>        Bird *bird = <span class="hljs-keyword">dynamic_cast</span>&lt;Bird *&gt;(obj); <span class="hljs-comment">// 对象转化</span><br>        bird-&gt;foraging();<br>    &#125;<br><br>    obj-&gt;<span class="hljs-built_in">land</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Bird *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bird</span>();<br>    <span class="hljs-built_in">doSomething</span>(b);<br>    <span class="hljs-keyword">delete</span> b;<br>    b = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Interview Q&amp;amp;A C/CPP&lt;/h1&gt;
&lt;h2 id=&quot;const&quot;&gt;const&lt;/h2&gt;
&lt;p&gt;int getValue();             // 普通成员函数&lt;/p&gt;
&lt;p&gt;? int getValue() const;       // </summary>
      
    
    
    
    
  </entry>
  
</feed>
