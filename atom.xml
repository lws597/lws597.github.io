<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lwscode</title>
  
  <subtitle>lws&#39; blog</subtitle>
  <link href="https://lwscode.cn/atom.xml" rel="self"/>
  
  <link href="https://lwscode.cn/"/>
  <updated>2021-04-26T11:20:15.854Z</updated>
  <id>https://lwscode.cn/</id>
  
  <author>
    <name>lws</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript学习note</title>
    <link href="https://lwscode.cn/p/1579/"/>
    <id>https://lwscode.cn/p/1579/</id>
    <published>2021-04-26T08:40:26.000Z</published>
    <updated>2021-04-26T11:20:15.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js语法">js语法</h2><h3 id="js语法学习demo">js语法学习<a href="https://github.com/lws597/web/tree/master/js">demo</a></h3><p>js作为一个脚本语言，语法学习简单。其中typeof操作符较为有意思，无类型语言竟然还有类型检查机制，回头给<a href="https://github.com/lws597/xlang">自制语言</a>添加一个typeof关键字。js的null和true/false为保留关键字，<a href="https://github.com/lws597/xlang">自制语言</a>的null和true/false也可设置为关键字，直接解析成0/1</p><h3 id="var-let-const">var &amp; let &amp; const</h3><p>let 声明的变量只在 let 命令所在的代码块内有效<br>const 声明一个只读的常量，一旦声明，常量的值就不能改变</p><p>for循环{}中多用let</p><h3 id="for…in-for…of">for…in &amp; for…of</h3><p>在循环对象属性的时候，使用for…in，for…in循环得到的是key<br>在遍历数组的时候的时候使用for…of，for…of循环得到的是value</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> aArray) &#123;<br>    <span class="hljs-built_in">console</span>.log(aArray[index]);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> aArray) &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="">&gt;&gt; &amp; &gt;&gt;&gt;</h3><p>运算符&gt;&gt;&gt;执行无符号右移位运算。它把无符号的32位整数所有数位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1000</span> &gt;&gt; <span class="hljs-number">8</span>);  <span class="hljs-comment">//返回值3</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1000</span> &gt;&gt;&gt; <span class="hljs-number">8</span>);  <span class="hljs-comment">//返回值3</span><br></code></pre></td></tr></table></figure><p>对于负数来说，无符号右移将使用0来填充所有的空位，同时会把负数作为正数来处理，所得结果会非常大</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(-<span class="hljs-number">1000</span> &gt;&gt; <span class="hljs-number">8</span>);  <span class="hljs-comment">//返回值 -4</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-number">1000</span> &gt;&gt;&gt; <span class="hljs-number">8</span>);  <span class="hljs-comment">//返回值 16777212</span><br></code></pre></td></tr></table></figure><h2 id="js刷题">js刷题</h2><h3 id="leetcode1189"><a href="https://leetcode-cn.com/problems/maximum-number-of-balloons">leetcode1189</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=1189 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [1189] “气球” 的最大数量</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">text</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxNumberOfBalloons = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> map = &#123;<span class="hljs-string">&#x27;a&#x27;</span> : <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;b&#x27;</span> : <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;o&#x27;</span> : <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;l&#x27;</span> : <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;n&#x27;</span> : <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ch <span class="hljs-keyword">of</span> text) &#123;<br>        map[ch]++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(map[<span class="hljs-string">&#x27;a&#x27;</span>], map[<span class="hljs-string">&#x27;b&#x27;</span>], map[<span class="hljs-string">&#x27;o&#x27;</span>] &gt;&gt; <span class="hljs-number">1</span>, map[<span class="hljs-string">&#x27;l&#x27;</span>] &gt;&gt; <span class="hljs-number">1</span>, map[<span class="hljs-string">&#x27;n&#x27;</span>]);<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br><br></code></pre></td></tr></table></figure><h3 id="leetcode944"><a href="https://leetcode-cn.com/problems/delete-columns-to-make-sorted">leetcode944</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=944 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [944] 删列造序</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">strs</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minDeletionSize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; strs.length - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (strs[j][i] &gt; strs[j + <span class="hljs-number">1</span>][i]) &#123;<br>                ans++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br><br></code></pre></td></tr></table></figure><h3 id="leetcode908"><a href="https://leetcode-cn.com/problems/smallest-range-i">leetcode908</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=908 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [908] 最小差值 I</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">K</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> smallestRangeI = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">A, K</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (A.length == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> delta = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, A) - <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, A) - (K &lt;&lt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> delta &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : delta;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br><br></code></pre></td></tr></table></figure><h3 id="leetcode38"><a href="https://leetcode-cn.com/problems/count-and-say">leetcode38</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=38 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [38] 外观数列</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countAndSay = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> pre = <span class="hljs-string">&quot;1&quot;</span>, cur = <span class="hljs-string">&quot;1&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        pre = cur;<br>        cur = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (r &lt; pre.length) &#123;<br>            <span class="hljs-keyword">while</span> (pre[l] === pre[r] &amp;&amp; r &lt; pre.length) &#123;<br>                r++;<br>            &#125;<br>            cur += (r - l).toString() + pre[l];<br>            l = r;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;js语法&quot;&gt;js语法&lt;/h2&gt;
&lt;h3 id=&quot;js语法学习demo&quot;&gt;js语法学习&lt;a href=&quot;https://github.com/lws597/web/tree/master/js&quot;&gt;demo&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;js作为一个脚本语言，语法学习简单。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Wps实习四个月后</title>
    <link href="https://lwscode.cn/p/3770/"/>
    <id>https://lwscode.cn/p/3770/</id>
    <published>2021-04-22T07:55:36.000Z</published>
    <updated>2021-04-26T11:15:10.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="wps实习四个月后的一些思考和新规划">wps实习四个月后的一些思考和新规划</h2><p>wps的实习已经告一段落，玩了一段时间，迷茫了一段时间，整理代码一段时间，现在写一篇思考。</p><h3 id="wps实习内容">wps实习内容</h3><p>在wps mac组实习四个月，接手的需求有：</p><ol><li><p>移植pc功能</p><ol><li>Excel批量计算</li></ol></li><li><p>交互功能</p><ol><li>空格键进入图片预览</li><li>双指滑动（滚轮）移动图片</li><li>双指拍&amp;双指捏缩放图片</li><li>双指旋旋转wps对象</li><li>双指/右键拖复制wps对象</li></ol></li><li><p>优化需求</p><ol><li>多级窗口modal规范</li><li>新建文本框默认设置添加选项</li><li>复制图片清晰度优化</li><li>Excel单个单元格复制形式改为纯文本</li></ol></li><li><p>半成品需求</p><ol><li>光标icon替换为高清图</li><li>Excel底部sheet平滑移动</li><li>文本框添加只复制文本功能</li><li>三指捏需求</li></ol></li></ol><p>感觉这些需求都挺无聊的，所以才交给一个实习生写吧。多级窗口modal规范，该需求阅读了大量qt源码。触控板扩展需求考察了一堆开源代码，学习了objective-c和swift。也就这两个需求有点意思。</p><h3 id="实习过程技术成长">实习过程技术成长</h3><p>刚入职先学习公司代码规范、工程规范，和一些工作流程。第一次用到心心念念的mac，也花了点时间来熟悉，用过很多发行版Linux，上手mac也很快。wps产品由用qt+c/cpp完成，技术方面先学习qt。第一个需求移植pc已有的Excel批量计算功能，需要添加的代码都在一起，不需要调试，直接上手敲码就好，qt方面也只需要学习dialog的创建，和事件的处理。第二个需求空格键进入图片预览，该有的api都有，但需要找到适合修改的代码块，因为不会调试所以花了一个多星期，还是最后组长教会了我调试来定位代码和了解功能的执行流程。后面都是一些调api的需求，以及学会qt某部分的使用就能写的需求。多级窗口modal规范需求，考察了很久才定位到qt的bug（pc没问题，mac有问题，应该第一时间就测试一下是不是qt的bug），为解决bug阅读了大量qt源码，对qt的一些特性有了更深了了解，学习框架还是得直接读源码。qt源码面向对象，以c++11为标准（qt6以c++17为标准），范型编程到处都是，可读性很好，比wps代码好的多。离职前的需求是mac触控板相关的，网上资料很少，只有github上有几个项目，为了看懂代码就去学了objective-c，顺便学了swift（语法方面c/cpp yyds，oc真反人类，swift也习惯不了）。做了一些考察才知道apple有Private API这个东西，mac触控板增强软件都用了这部分api，wps不可能用的，产品的一些需求也就得打回了。不用写多指需求了，但多指滑、多指捏在继续考察，应该可以通过触控点的坐标识别手势，但自定义手势多了可能就不能做到精准识别了。</p><h3 id="实习过程不足">实习过程不足</h3><p>实习过程还是有一些问题暴露出来。最大的问题应该就是不喜欢码字，提测邮件都不想写，周报和提测邮件被cue过，组长让我写开发文档也一次没写过。感觉码字的问题需要正视一下，不仅是工作流程中的常规码字，还有一些技术分享内容，这也是对个人和工作都有帮助的。所以打算以后以该blog为契机多写一些技术分享内容。由于实习疏忽了算法题，现在很多题的解法都生疏了。现在回头看刷算法题确实可以提升思维，也是为了以后面试做准备，应该让刷算法题成为一个习惯。之前刷了一堆不同难度的算法题，几乎覆盖了所有类型的算法，但没有做过一次归纳总结，也没写过一篇算法文章。今后每天刷一定量题，也要做归纳总结写稿。大学技术积累只有c/cpp，其他技术都不会，不会一个框架，没有达到技术上的广度。今后需要多积累一些其他技术，学习一下go、web前端、机器学习，和一些较火的框架。新技术的积累是从头开始，学习过程也要通过blog形式记录一下。虽说大学只学了c/cpp，但深度也是没达到的，引以为傲的语言方面和大佬交流后发现，还是有一堆东西不知道的。c/cpp的一些附属技术也只是了解。短期内没有转技术的想法，所以技术方面还是以c/cpp方面为主。wps实习是一次接触大型的工程代码，为了更好的写工程代码，还需要学习重构相关的技巧，架构知识入门，熟练掌握范型编程，设计模式熟练选择和运用。</p><h3 id="对未来的焦虑">对未来的焦虑</h3><p>老实说工作和我想象中的并不一样，你不是只需要一心一意的写好你的代码就好。还需要和其他人对接，完成自己的okr，完成小组的okr。牺牲个人，顺应小组的方向。个人对公司来说就是一颗螺丝钉，在我所做的工作压根看不到自己的痕迹，做的技术也是没意思的CURD，写一些shit需求的业务代码，和一些前辈聊了之后发现大厂也有这般问题。之前重来没想过这个问题，就算想到了也不会觉得这是个问题。实习离职后也思考一番人生，还冒出自己创业的可笑想法。b站UP主推荐《软技能》一书，在书中找到了一些问题的答案。工作了就要尽量别让工作侵占生活，下班后可以自己做饭、去健身，养一只猫，做一些技术之外的事。而打工这件事应该要以平常心对待，工作是公司的，个人发展是自己的。技术方面下班后刷几个算法题，看几篇技术文章，也要做到技术产出。</p><p>好好学习吧。技术和money都会有的！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;wps实习四个月后的一些思考和新规划&quot;&gt;wps实习四个月后的一些思考和新规划&lt;/h2&gt;
&lt;p&gt;wps的实习已经告一段落，玩了一段时间，迷茫了一段时间，整理代码一段时间，现在写一篇思考。&lt;/p&gt;
&lt;h3 id=&quot;wps实习内容&quot;&gt;wps实习内容&lt;/h3&gt;
&lt;p&gt;在w</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vim查找&amp;替换</title>
    <link href="https://lwscode.cn/p/5304/"/>
    <id>https://lwscode.cn/p/5304/</id>
    <published>2021-04-20T03:09:18.000Z</published>
    <updated>2021-04-26T11:15:10.712Z</updated>
    
    <content type="html"><![CDATA[<h1>vim中的查找与替换</h1><h5 id="1-查找"><strong>1.查找</strong></h5><p>在normal模式下按下<code>/</code>即可进入查找模式，输入要查找的字符串并按下回车。 Vim会跳转到第一个匹配。按下<code>n</code>查找下一个，按下<code>N</code>查找上一个。</p><p>Vim查找支持正则表达式，例如<code>/vim$</code>匹配行尾的<code>&quot;vim&quot;</code>。 需要查找特殊字符需要转义，例如<code>/vim\$</code>匹配<code>&quot;vim$&quot;</code>。</p><h5 id="2-大小写敏感查找"><strong>2.大小写敏感查找</strong></h5><p>在查找模式中加入<code>\c</code>表示大小写不敏感查找，<code>\C</code>表示大小写敏感查找。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;foo\c<br></code></pre></td></tr></table></figure><p>将会查找所有的<code>&quot;foo&quot;</code>,<code>&quot;FOO&quot;</code>,<code>&quot;Foo&quot;</code>等字符串。</p><h5 id="3-大小写敏感配置"><strong>3.大小写敏感配置</strong></h5><p>Vim 默认采用大小写敏感的查找，为了方便我们常常将其配置为大小写不敏感：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot; 设置默认进行大小写不敏感查找<br>set ignorecase<br>&quot; 如果有一个大写字母，则切换到大小写敏感查找<br>set smartcase <br></code></pre></td></tr></table></figure><blockquote><p>将上述设置粘贴到你的<code>~/.vimrc</code>，重新打开Vim即可生效</p></blockquote><h5 id="4-查找当前单词"><strong>4.查找当前单词</strong></h5><p>在normal模式下按下<code>*</code>即可查找光标所在单词（word）， 要求每次出现的前后为空白字符或标点符号。例如当前为<code>foo</code>， 可以匹配<code>foo bar</code>中的<code>foo</code>，但不可匹配<code>foobar</code>中的<code>foo</code>。 这在查找函数名、变量名时非常有用。</p><p>按下<code>g*</code>即可查找光标所在单词的字符序列，每次出现前后字符无要求。 即<code>foo bar</code>和<code>foobar</code>中的<code>foo</code>均可被匹配到。</p><h5 id="5-查找与替换"><strong>5.查找与替换</strong></h5><p><code>:s</code>（substitute）命令用来查找和替换字符串。语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:&#123;作用范围&#125;s&#x2F;&#123;目标&#125;&#x2F;&#123;替换&#125;&#x2F;&#123;替换标志&#125;<br></code></pre></td></tr></table></figure><p>例如<code>:%s/foo/bar/g</code>会在全局范围(<code>%</code>)查找<code>foo</code>并替换为<code>bar</code>，所有出现都会被替换（<code>g</code>）</p><h5 id="6-作用范围"><strong>6.作用范围</strong></h5><p>作用范围分为当前行、全文、选区等等。</p><p>当前行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:s&#x2F;foo&#x2F;bar&#x2F;g<br></code></pre></td></tr></table></figure><p>全文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:%s&#x2F;foo&#x2F;bar&#x2F;g<br></code></pre></td></tr></table></figure><p>选区，在Visual模式下选择区域后输入<code>:</code>，Vim即可自动补全为 <code>:'&lt;,'&gt;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:&#39;&lt;,&#39;&gt;s&#x2F;foo&#x2F;bar&#x2F;g<br></code></pre></td></tr></table></figure><p>2-11行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:5,12s&#x2F;foo&#x2F;bar&#x2F;g<br></code></pre></td></tr></table></figure><p>当前行<code>.</code>与接下来两行<code>+2</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:.,+2s&#x2F;foo&#x2F;bar&#x2F;g<br></code></pre></td></tr></table></figure><h2 id="替换标志">替换标志</h2><p>上文中命令结尾的<code>g</code>即是替换标志之一，表示全局<code>global</code>替换（即替换目标的所有出现）。 还有很多其他有用的替换标志：</p><p>空替换标志表示只替换从光标位置开始，目标的第一次出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:%s&#x2F;foo&#x2F;bar<br></code></pre></td></tr></table></figure><p><code>i</code>表示大小写不敏感查找，<code>I</code>表示大小写敏感：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">:%s&#x2F;foo&#x2F;bar&#x2F;i<br># 等效于模式中的\c（不敏感）或\C（敏感）<br>:%s&#x2F;foo\c&#x2F;bar<br></code></pre></td></tr></table></figure><p><code>c</code>表示需要确认，例如全局查找<code>&quot;foo&quot;</code>替换为<code>&quot;bar&quot;</code>并且需要确认：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">:%s&#x2F;foo&#x2F;bar&#x2F;gc<br></code></pre></td></tr></table></figure><p>回车后Vim会将光标移动到每一次<code>&quot;foo&quot;</code>出现的位置，并提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">replace with bar (y&#x2F;n&#x2F;a&#x2F;q&#x2F;l&#x2F;^E&#x2F;^Y)?<br></code></pre></td></tr></table></figure><p>按下<code>y</code>表示替换，<code>n</code>表示不替换，<code>a</code>表示替换所有，<code>q</code>表示退出查找模式， <code>l</code>表示替换当前位置并退出。<code>^E</code>与<code>^Y</code>是光标移动快捷键，参考： <a href="http://harttle.com/2015/11/07/vim-cursor.html">Vim中如何快速进行光标移</a></p><h2 id="大小写敏感查找">大小写敏感查找</h2><p>在查找模式中加入<code>\c</code>表示大小写不敏感查找，<code>\C</code>表示大小写敏感查找。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;foo\c<br></code></pre></td></tr></table></figure><p>将会查找所有的<code>&quot;foo&quot;</code>,<code>&quot;FOO&quot;</code>,<code>&quot;Foo&quot;</code>等字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;vim中的查找与替换&lt;/h1&gt;
&lt;h5 id=&quot;1-查找&quot;&gt;&lt;strong&gt;1.查找&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;在normal模式下按下&lt;code&gt;/&lt;/code&gt;即可进入查找模式，输入要查找的字符串并按下回车。 Vim会跳转到第一个匹配。按下&lt;code&gt;n&lt;/c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="https://lwscode.cn/p/9423/"/>
    <id>https://lwscode.cn/p/9423/</id>
    <published>2021-04-20T03:07:52.000Z</published>
    <updated>2021-04-26T11:15:10.709Z</updated>
    
    <content type="html"><![CDATA[<h1>Interview Q&amp;A STL</h1><h2 id="B-树（B-tree）、B-树（B±tree）">B 树（B-tree）、B+ 树（B±tree）</h2><h3 id="特点">特点</h3><ul><li>一般化的二叉查找树（binary search tree）</li><li>“矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）</li></ul><h3 id="应用">应用</h3><ul><li>大部分文件系统、数据库系统都采用B树、B+树作为索引结构</li></ul><h3 id="区别">区别</h3><ul><li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点。</li><li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li></ul><h3 id="B树的优点">B树的优点</h3><ul><li>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</li></ul><h3 id="B-树的优点">B+树的优点</h3><ul><li>非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li><li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li></ul><h2 id="STL-容器">STL 容器</h2><table><thead><tr><th>容器</th><th>底层数据结构</th><th>时间复杂度</th><th>有无序</th><th>可不可重复</th><th>其他</th></tr></thead><tbody><tr><td>array</td><td>数组</td><td>随机读改 O(1)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td>vector</td><td>数组</td><td>随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td>deque</td><td>双端队列</td><td>头尾插入、头尾删除 O(1)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td>forward_list</td><td>单向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td>list</td><td>双向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td>stack</td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td>queue</td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td>priority_queue</td><td>vector + max-heap</td><td>插入、删除 O(log2n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td>set</td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td>multiset</td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td>map</td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td>multimap</td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td>unordered_set</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td>unordered_multiset</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td>unordered_map</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td>unordered_multimap</td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Interview Q&amp;amp;A STL&lt;/h1&gt;
&lt;h2 id=&quot;B-树（B-tree）、B-树（B±tree）&quot;&gt;B 树（B-tree）、B+ 树（B±tree）&lt;/h2&gt;
&lt;h3 id=&quot;特点&quot;&gt;特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一般化的二叉查找树（binary </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Socket</title>
    <link href="https://lwscode.cn/p/34204/"/>
    <id>https://lwscode.cn/p/34204/</id>
    <published>2021-04-20T03:05:34.000Z</published>
    <updated>2021-04-26T11:15:10.712Z</updated>
    
    <content type="html"><![CDATA[<p>我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket的基本函数，这些都是本文想介绍的。本文的主要内容如下：</p><ul><li>1、网络中进程之间如何通信？</li><li>2、Socket是什么？</li><li>3、socket的基本操作<ul><li>3.1、socket()函数</li><li>3.2、bind()函数</li><li>3.3、listen()、connect()函数</li><li>3.4、accept()函数</li><li>3.5、read()、write()函数等</li><li>3.6、close()函数</li></ul></li><li>4、socket中TCP的三次握手建立连接详解</li><li>5、socket中TCP的四次握手释放连接详解</li></ul><h1>1、网络中进程之间如何通信？</h1><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><p>但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机，而传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><p>使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。</p><h1>2、什么是Socket？</h1><p>上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。</p><blockquote><h3 id="socket一词的起源">socket一词的起源</h3><p>在组网领域的首次使用是在1970年2月12日发布的文献<a href="http://datatracker.ietf.org/doc/rfc33/">IETF RFC33</a>中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”</p></blockquote><h1>3、socket的基本操作</h1><p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p><h2 id="3-1、socket-函数">3.1、socket()函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">int socket(int domain, int type, int protocol);<br></code></pre></td></tr></table></figure><p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而**socket()**用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li><li>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。</li></ul><p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p><p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p><h2 id="3-2、bind-函数">3.2、bind()函数</h2><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br></code></pre></td></tr></table></figure><p>函数的三个参数分别为：</p><ul><li><p>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：一个 const struct sockaddr* 指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">struct sockaddr_in &#123;<br>      sa_family_t    sin_family; &#x2F;* address family: AF_INET *&#x2F;<br>    in_port_t      sin_port;   &#x2F;* port in network byte order *&#x2F;<br>      struct in_addr sin_addr;   &#x2F;* internet address *&#x2F;<br>&#125;;<br>  <br></code></pre></td></tr></table></figure></li></ul><p>/* Internet address. <em>/<br>struct in_addr {<br>uint32_t       s_addr;     /</em> address in network byte order */<br>};</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>ipv6对应的是：<br><br></code></pre></td></tr></table></figure><p>struct sockaddr_in6 {<br>sa_family_t     sin6_family;   /* AF_INET6 <em>/<br>in_port_t       sin6_port;     /</em> port number <em>/<br>uint32_t        sin6_flowinfo; /</em> IPv6 flow information <em>/<br>struct in6_addr sin6_addr;     /</em> IPv6 address <em>/<br>uint32_t        sin6_scope_id; /</em> Scope ID (new in 2.4) */<br>};</p><p>struct in6_addr {<br>unsigned char   s6_addr[16];   /* IPv6 address */<br>};</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>Unix域对应的是：<br><br></code></pre></td></tr></table></figure><p>#define UNIX_PATH_MAX    108</p><p>struct sockaddr_un {<br>sa_family_t sun_family;               /* AF_UNIX <em>/<br>char        sun_path[UNIX_PATH_MAX];  /</em> pathname */<br>};</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">  <br>- addrlen：对应的是地址的长度。<br><br>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。<br><br>&gt; ### 网络字节序与主机字节序<br>&gt;<br>&gt; **主机字节序**就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：<br>&gt;<br>&gt; 　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>&gt;<br>&gt; 　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br>&gt;<br>&gt; **网络字节序**：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。**由于TCP&#x2F;IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。**字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。<br>&gt;<br>&gt; 所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。<br><br>## 3.3、listen()、connect()函数<br><br>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。<br><br></code></pre></td></tr></table></figure><p>int listen(int sockfd, int backlog);<br>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。<br><br>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。<br><br>## 3.4、accept()函数<br><br>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I&#x2F;O操作了，即类同于普通文件的读写I&#x2F;O操作。<br><br></code></pre></td></tr></table></figure><p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。<br><br>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。<br><br>## 3.5、read()、write()等函数<br><br>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I&#x2F;O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I&#x2F;O操作有下面几组：<br><br>- read()&#x2F;write()<br>- recv()&#x2F;send()<br>- readv()&#x2F;writev()<br>- recvmsg()&#x2F;sendmsg()<br>- recvfrom()&#x2F;sendto()<br><br>我推荐使用recvmsg()&#x2F;sendmsg()函数，这两个函数是最通用的I&#x2F;O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：<br><br></code></pre></td></tr></table></figure><pre><code>   #include &lt;unistd.h&gt;   ssize_t read(int fd, void *buf, size_t count);   ssize_t write(int fd, const void *buf, size_t count);   #include &lt;sys/types.h&gt;   #include &lt;sys/socket.h&gt;   ssize_t send(int sockfd, const void *buf, size_t len, int flags);   ssize_t recv(int sockfd, void *buf, size_t len, int flags);   ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,                  const struct sockaddr *dest_addr, socklen_t addrlen);   ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,                    struct sockaddr *src_addr, socklen_t *addrlen);   ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);   ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。<br><br>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。<br><br>其它的我就不一一介绍这几对I&#x2F;O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send&#x2F;recv。<br><br>## 3.6、close()函数<br><br>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。<br><br></code></pre></td></tr></table></figure><p>#include &lt;unistd.h&gt;<br>int close(int fd);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。<br><br>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。<br><br># 4、socket中TCP的三次握手建立连接详解<br><br>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：<br><br>- 客户端向服务器发送一个SYN J<br>- 服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1<br>- 客户端再想服务器发一个确认ACK K+1<br><br>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：<br><br>[![image](https:&#x2F;&#x2F;images.cnblogs.com&#x2F;cnblogs_com&#x2F;skynet&#x2F;201012&#x2F;201012122157476286.png)](http:&#x2F;&#x2F;images.cnblogs.com&#x2F;cnblogs_com&#x2F;skynet&#x2F;201012&#x2F;201012122157467258.png)<br><br>图1、socket中发送的TCP三次握手<br><br>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。<br><br>&gt; 总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。<br><br># 5、socket中TCP的四次握手释放连接详解<br><br>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：<br><br>[![image](https:&#x2F;&#x2F;images.cnblogs.com&#x2F;cnblogs_com&#x2F;skynet&#x2F;201012&#x2F;201012122157494693.png)](http:&#x2F;&#x2F;images.cnblogs.com&#x2F;cnblogs_com&#x2F;skynet&#x2F;201012&#x2F;201012122157487616.png)<br><br>图2、socket中发送的TCP四次握手<br><br>图示过程如下：<br><br>- 某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；<br>- 另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；<br>- 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；<br>- 接收到这个FIN的源发送端TCP对它进行确认。<br><br>这样每个方向上都有一个FIN和ACK。<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RBTree</title>
    <link href="https://lwscode.cn/p/60718/"/>
    <id>https://lwscode.cn/p/60718/</id>
    <published>2021-04-20T03:04:42.000Z</published>
    <updated>2021-04-26T11:15:10.709Z</updated>
    
    <content type="html"><![CDATA[<h1>RedBlack_Tree</h1><h2 id="五个条件">五个条件</h2><ol><li>节点非黑即红</li><li>根节点是黑色的</li><li>叶节点(NIL)是黑色的</li><li>如果一个节点是红色的，则它的两个子节点都是黑色的</li><li>从根节点出发到所有叶节点路径上，黑色节点数量相同</li></ol><p>最短路径全黑，节点数a，最长路径有相同多个黑色节点（条件5）</p><p>，红色节点不能连续（条件4），节点数2a</p><h2 id="调整策略">调整策略</h2><p>插入节点站在祖父节点看</p><p>删除调整站在父节点看</p><h3 id="插入调整">插入调整</h3><p>用带有两个黑色的NIL的新节点替换NIL叶节点</p><p>为了方便调整，新结点初始为红色（黑色节点影响条件5）</p><h4 id="情况一">情况一</h4><p>插入节点的父节点是黑色</p><p>直接插入</p><h4 id="情况二">情况二</h4><p>插入节点的父节点和叔节点都是红色</p><p>父节点、叔节点染成黑色，祖父节点染成红色</p><h4 id="情况三LL">情况三LL</h4><p>插入节点的父节点是红色，叔节点是黑色，插入节点是父节点的左孩子，父节点是祖父节点的左孩子</p><p>祖父节点右旋，祖父节点染成红色，父节点染成黑色</p><h4 id="情况四LR">情况四LR</h4><p>插入节点的父节点是红色，叔节点是黑色，插入节点是父节点的右孩子，父节点是祖父节点的左孩子</p><p>父节点左旋，转换为情况三（祖父节点右旋，祖父节点染成红色，父节点染成黑色）</p><h3 id="删除调整">删除调整</h3><h4 id="情况一-2">情况一</h4><p>兄弟节点是红色</p><p>父节点左旋，父节点染成红色，兄弟节点染成黑色</p><h4 id="情况二-2">情况二</h4><p>父节点、兄弟节点和兄弟节点的子节点都是黑色</p><p>父节点左旋，父节点染成红色</p><h4 id="情况三">情况三</h4><p>父节点红色，兄弟节点和兄弟节点的子节点都是黑色</p><p>父节点左旋</p><h4 id="情况四">情况四</h4><p>父节点任意颜色，兄弟节点的右儿子红色，删除节点是父节点的左儿子</p><p>父节点左旋，交换父节点、兄弟节点的颜色，兄弟节点的右孩子染成黑色</p><h4 id="情况五">情况五</h4><p>父节点任意颜色，兄弟节点的左儿子红色，删除节点是父节点的左儿子</p><p>兄弟节点染成红色，兄弟节点的左儿子染成黑色，兄弟节点右旋，转换为情况四</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RedBlack_Tree&lt;/h1&gt;
&lt;h2 id=&quot;五个条件&quot;&gt;五个条件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;节点非黑即红&lt;/li&gt;
&lt;li&gt;根节点是黑色的&lt;/li&gt;
&lt;li&gt;叶节点(NIL)是黑色的&lt;/li&gt;
&lt;li&gt;如果一个节点是红色的，则它的两个子节点都是黑色的&lt;/li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Printf</title>
    <link href="https://lwscode.cn/p/12527/"/>
    <id>https://lwscode.cn/p/12527/</id>
    <published>2021-04-20T03:03:19.000Z</published>
    <updated>2021-04-26T11:15:10.712Z</updated>
    
    <content type="html"><![CDATA[<p>printf输出颜色和ANSI控制码(高亮,下划线,闪烁,光标位置,清屏等)</p><p>颜色：</p><p>#define NONE “/033[m”</p><p>#define RED “/033[0;32;31m”</p><p>#define LIGHT_RED “/033[1;31m”</p><p>#define GREEN “/033[0;32;32m”</p><p>#define LIGHT_GREEN “/033[1;32m”</p><p>#define BLUE “/033[0;32;34m”</p><p>#define LIGHT_BLUE “/033[1;34m”</p><p>#define DARY_GRAY “/033[1;30m”</p><p>#define CYAN “/033[0;36m”</p><p>#define LIGHT_CYAN “/033[1;36m”</p><p>#define PURPLE “/033[0;35m”</p><p>#define LIGHT_PURPLE “/033[1;35m”</p><p>#define BROWN “/033[0;33m”</p><p>#define YELLOW “/033[1;33m”</p><p>#define LIGHT_GRAY “/033[0;37m”</p><p>#define WHITE “/033[1;37m”</p><p>比如：</p><p>printf(“/033[31m ####-----&gt;&gt; /033[32m” “hello/n” “/033[m”)</p><p>int main()</p><p>{</p><p>printf( CYAN “current function is %s &quot; GREEN &quot; file line is %d/n” NONE,</p><p><strong>FUNCTION</strong>, <strong>LINE</strong> );</p><p>fprintf(stderr, RED “current function is %s &quot; BLUE &quot; file line is %d/n” NONE,</p><p><strong>FUNCTION</strong>, <strong>LINE</strong> );</p><p>return 0;</p><p>}</p><p>颜色分为背景色和字体色，30~39用来设置字体色，40~49设置背景：</p><p>背景色 字体色</p><p>40: 黑 30: 黑</p><p>41: 红 31: 红</p><p>42: 绿 32: 绿</p><p>43: 黄 33: 黄</p><p>44: 蓝 34: 蓝</p><p>45: 紫 35: 紫</p><p>46: 深绿 36: 深绿</p><p>47: 白色 37: 白色</p><p>记得在打印完之后，把颜色恢复成NONE，不然再后面的打印都会跟着变色。</p><p>另外，还可以加一些ANSI控制码。加颜色只是以下控制码中的一种：</p><p>/033[0m 关闭所有属性</p><p>/033[1m 设置高亮度</p><p>/033[4m 下划线</p><p>/033[5m 闪烁</p><p>/033[7m 反显</p><p>/033[8m 消隐</p><p>/033[30m – /033[37m 设置前景色</p><p>/033[40m – /033[47m 设置背景色</p><p>/033[nA 光标上移n行</p><p>/033[nB 光标下移n行</p><p>/033[nC 光标右移n行</p><p>/033[nD 光标左移n行</p><p>/033[y;xH设置光标位置</p><p>/033[2J 清屏</p><p>/033[K 清除从光标到行尾的内容</p><p>/033[s 保存光标位置</p><p>/033[u 恢复光标位置</p><p>/033[?25l 隐藏光标</p><p>/033[?25h 显示光标</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;printf输出颜色和ANSI控制码(高亮,下划线,闪烁,光标位置,清屏等)&lt;/p&gt;
&lt;p&gt;颜色：&lt;/p&gt;
&lt;p&gt;#define NONE “/033[m”&lt;/p&gt;
&lt;p&gt;#define RED “/033[0;32;31m”&lt;/p&gt;
&lt;p&gt;#define LIGHT_RE</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Note4</title>
    <link href="https://lwscode.cn/p/34591/"/>
    <id>https://lwscode.cn/p/34591/</id>
    <published>2021-04-20T03:01:49.000Z</published>
    <updated>2021-04-26T11:15:10.712Z</updated>
    
    <content type="html"><![CDATA[<h1>DAY05</h1><h2 id="输出函数说明">输出函数说明</h2><p>printf函数</p><ul><li>头文件:stdio.h</li><li>原型:int printf(const char *format,…);</li><li>format:格式控制字符串</li><li>…:可变参数列表</li><li>返回值:输出字符类型</li></ul><h2 id="输出函数说明-2">输出函数说明</h2><p>scanf函数</p><ul><li>头文件:stdio.h</li><li>原型:int scanf(const char *format,…);</li><li>format:格式控制字符</li><li>…:可变参数列表</li><li>返回值:成功读入列表</li></ul><p>请使用printf函数,求解一个数字n的十进制表示的数字位数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include&lt;stdio.h&gt;<br>int main()&#123;<br>    int n;<br>    while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;<br>        printf(&quot; has %d digits\n&quot;,printf(&quot;%d&quot;,n));<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>请写一个程序,读入一个行字符串(可能包含空格),输出这个字符串中字符的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include&lt;stdio.h&gt;<br>int main()&#123;<br>    char str[100];<br>    while(scanf(&quot;%[^\n]s&quot;,str)!&#x3D;EOF) &#123;<br>        getchar();<br>        printf(&quot; has %d chars\n&quot;,printf(&quot;%s&quot;,str));<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sprintf和fprintf代码演示">sprintf和fprintf代码演示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include &lt;stdio.h&gt;<br>#define swap(a, b) &#123; \<br>    __typeof(a) temp &#x3D; a;\<br>    a &#x3D; b, b &#x3D; temp; \<br>&#125;<br><br>int main() &#123;<br>    printf(&quot;%c\n&quot;, 97);<br>    int n;<br>    scanf(&quot;%d&quot;, &amp;n);<br>    printf(&quot;%04d\n&quot;, n);<br>    char str[100], buff[100], *p &#x3D; str, *q &#x3D; buff;<br>    sprintf(str, &quot;%d.%d.%d.%d&quot;, 192,168,1,10);<br>    printf(&quot;str&#x3D;%s\n&quot;, str);<br>    if (n &amp; 1) &#123;<br>        sprintf(q, &quot;(%s)&quot;, p);<br>        swap(p, q);<br>    &#125;<br>    if (n &amp; 2) &#123;<br>        sprintf(q, &quot;[%s]&quot;, p);<br>        swap(p, q);<br>    &#125;<br>    if (n &amp; 4) &#123;<br>        sprintf(q, &quot;&#123;%s&#125;&quot;, p);<br>        swap(p, q);<br>    &#125;<br>    FILE *fout &#x3D; fopen(&quot;output&quot;, &quot;w&quot;);<br>    fprintf(stdout, &quot;stdout &#x3D; %s\n&quot;, p);<br>    fprintf(stderr, &quot;stderr &#x3D; %s\n&quot;, p);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DAY05&lt;/h1&gt;
&lt;h2 id=&quot;输出函数说明&quot;&gt;输出函数说明&lt;/h2&gt;
&lt;p&gt;printf函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头文件:stdio.h&lt;/li&gt;
&lt;li&gt;原型:int printf(const char *format,…);&lt;/li&gt;
&lt;li&gt;forma</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Note3</title>
    <link href="https://lwscode.cn/p/17758/"/>
    <id>https://lwscode.cn/p/17758/</id>
    <published>2021-04-20T03:01:06.000Z</published>
    <updated>2021-04-26T11:15:10.711Z</updated>
    
    <content type="html"><![CDATA[<h1>DAY04</h1><h2 id="使用github管理代码">使用github管理代码</h2><h3 id="创建一个空目录">创建一个空目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">mkdir hzoj<br>cd hzoj<br>pwd<br></code></pre></td></tr></table></figure><h3 id="把目录变成git仓库">把目录变成git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">git init<br></code></pre></td></tr></table></figure><h3 id="把文件添加到仓库">把文件添加到仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">git add *<br></code></pre></td></tr></table></figure><h3 id="把文件提交到仓库">把文件提交到仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">git commit *<br></code></pre></td></tr></table></figure><h3 id="查看结果">查看结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">git status<br></code></pre></td></tr></table></figure><h3 id="把本地库的所有内容推送到远程库上">把本地库的所有内容推送到远程库上</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">git remote add origin git@github.com:lws597&#x2F;HZOJ.git<br>git push -u origin master<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DAY04&lt;/h1&gt;
&lt;h2 id=&quot;使用github管理代码&quot;&gt;使用github管理代码&lt;/h2&gt;
&lt;h3 id=&quot;创建一个空目录&quot;&gt;创建一个空目录&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Note2</title>
    <link href="https://lwscode.cn/p/34207/"/>
    <id>https://lwscode.cn/p/34207/</id>
    <published>2021-04-20T03:00:15.000Z</published>
    <updated>2021-04-26T11:15:10.711Z</updated>
    
    <content type="html"><![CDATA[<h1>DAY03</h1><h2 id="Linux极简入门">Linux极简入门</h2><h3 id="文件与目录的管理">文件与目录的管理</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>ls</td><td>显示文件及目录信息</td></tr><tr><td>cp</td><td>拷贝</td></tr><tr><td>rm</td><td>删除</td></tr><tr><td>mv</td><td>移动</td></tr></tbody></table><h3 id="cp拷贝">cp拷贝</h3><p>cp [irapdslu] <sour> <dest></p><p>选项</p><ul><li>-i若文件存在，询问用户</li><li>-r递归复制</li><li>-apdr的集合</li><li>-p连同文件属性一起拷贝</li><li>-d若源文件为连接文件的属性，则复制连接文件的属性</li><li>-s拷贝为软连接</li><li>-l拷贝为硬连接</li><li>-u源文件比目的文件新才拷贝</li></ul><h3 id="rm删除">rm删除</h3><p>rm [irf] &lt;dir_or_file&gt;</p><p>选项</p><ul><li>-i互动模式</li><li>-r递归删除</li><li>-fforce</li></ul><h3 id="mv移动">mv移动</h3><p>mv [ifu] &lt;source…&gt; <dest></p><ul><li>mv source1 source2 souce3 dir</li></ul><p>选项</p><ul><li>-i互动模式</li><li>-fforce</li><li>-u源文件更新才会移动</li></ul><h3 id="文件内容的查阅">文件内容的查阅</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cat</td><td>正向连接读</td></tr><tr><td>tac</td><td>反向连接读</td></tr><tr><td>nl</td><td>输出行号显示文件</td></tr><tr><td>more</td><td>一页一页的显示文件内容</td></tr><tr><td>less</td><td>与more相似，但是可以上下翻看</td></tr><tr><td>head</td><td>只看头几行</td></tr><tr><td>tail</td><td>只看末尾几行</td></tr></tbody></table><h3 id="cat正向连续读">cat正向连续读</h3><p>cat [-AbEnTv] <file></p><p>选项:</p><ul><li>-A:相当于-vET</li><li>-v:列出看不出的字符</li><li>-E:显示断行符为$</li><li>-T:显示TAB为^T</li><li>-b:列出行号</li><li>-n:列出行号,连同空行也编号</li></ul><h3 id="tac反向连续读">tac反向连续读</h3><p>刚好与cat相反,从最后一行开始打印</p><h3 id="nl输出行号显示文件">nl输出行号显示文件</h3><p>nl [-bnw] <file></p><p>选项</p><ul><li>-b:行号指定的方式</li><li><ul><li>-b a:相当于cat -n</li><li>-b t:相当于cat -b</li></ul></li><li>-n:列出行号的表示方法</li><li><ul><li>-n ln:行号在屏幕最左边显示</li><li>-n rn:行号在自己字段的最右边显示</li><li>-n rz:行号在自己字段的最右边显示,前面自动补全0</li></ul></li><li>-w <num>:行号所占位数</li></ul><h3 id="more按页查看">more按页查看</h3><p>more file</p><ul><li>/string向下查找string关键字</li><li>:f显示文件名称和当前显示的行数</li><li>q离开</li></ul><h3 id="less按页查看">less按页查看</h3><p>less file</p><ul><li>/string向下查找n:继续向下查找</li><li>/?string反向查找N:继续反向查询</li></ul><h3 id="head查看头几行">head查看头几行</h3><p>head [-n num] <file></p><ul><li>-n num:显示前num行</li></ul><h3 id="tail查看末尾几行">tail查看末尾几行</h3><p>tail [-n num] <file></p><ul><li>-n num:显示文件后num行</li><li>-f:force</li></ul><p>如何查看一个文件的101行到120行?</p><p>man ls | nl -b a -w 5 -n rz | head -n 120 | tail -n 20</p><h3 id="man手册">man手册</h3><ol><li>man手册页分为下面几个部分:</li><li>普通命令</li><li>内核提供的系统调用</li><li>库调用(C库函数)</li><li>特殊文件(大多数在/dev目录下)和设备</li><li>文件格式规范</li><li>游戏</li><li>杂项(及其规范)</li><li>系统管理命令(通常需要root权限)和守护进程</li></ol><h2 id="配置wifi">配置wifi</h2><h3 id="打开终端-执行命令">打开终端,执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo service NetworkManager stop#关闭NetworkManager<br>sudo service NetworkManager start#开启NetworkManager<br></code></pre></td></tr></table></figure><h3 id="执行命令-查看网卡命名">执行命令,查看网卡命名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ifcongif -a<br></code></pre></td></tr></table></figure><h3 id="更改interfaces配置">更改interfaces配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo vim &#x2F;etc&#x2F;network&#x2F;interfaces<br></code></pre></td></tr></table></figure><p>在文本框中输入,保存并退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">auto wlp3s0<br>allow-hotplug wlp3s0<br>iface wlp3s0 inet dhcp<br>pre-up wpa_supplicant -Dwext -i wlp3s0 -c &#x2F;etc&#x2F;wpa_supplicant&#x2F;wpa_supplicant.conf -B<br></code></pre></td></tr></table></figure><h3 id="编辑wpa-supplicant-conf">编辑wpa_supplicant.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo vim &#x2F;etc&#x2F;wpa_supplicant&#x2F;wpa_supplicant.conf <br></code></pre></td></tr></table></figure><p>在文本框中输入,保存并退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">country&#x3D;CN<br>ctrl_interface&#x3D;DIR&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant GROUP&#x3D;netdev<br>update_config&#x3D;1<br>network&#x3D;&#123;<br>    ssid&#x3D;&quot;HaiZei_Tech&quot;<br>    psk&#x3D;&quot;HaiZei731.&quot;<br>    scan_ssid&#x3D;1<br>    priority&#x3D;3<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更改DNS">更改DNS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo vim &#x2F;etc&#x2F;resolv.conf<br></code></pre></td></tr></table></figure><p>nameserver 8.8.8.8</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DAY03&lt;/h1&gt;
&lt;h2 id=&quot;Linux极简入门&quot;&gt;Linux极简入门&lt;/h2&gt;
&lt;h3 id=&quot;文件与目录的管理&quot;&gt;文件与目录的管理&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Note1</title>
    <link href="https://lwscode.cn/p/34015/"/>
    <id>https://lwscode.cn/p/34015/</id>
    <published>2021-04-20T02:59:05.000Z</published>
    <updated>2021-04-26T11:15:10.711Z</updated>
    
    <content type="html"><![CDATA[<h1>DAY01</h1><h2 id="更新源">更新源</h2><h3 id="打开终端（Ctrl-Alt-T），执行命令">打开终端（Ctrl+Alt+T），执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo gedit &#x2F;etc&#x2F;apt&#x2F;sources.list<br></code></pre></td></tr></table></figure><h3 id="将文本框的内容删除，粘贴以下内容-保存并退出">将文本框的内容删除，粘贴以下内容,保存并退出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse<br>deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse<br>deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse<br>deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse<br>deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse<br>deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse<br>deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse<br>deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse<br>deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse<br>deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>·预先加载的应用（apt-get install preload）能识别一个用户最常用的<br>程序，也能把二进制文件和依赖性预先加载到内存，以提供更快速的访<br>问。随着安装后的第一次重启，它会自动运行。<br>·BleachBit（apt-get install bleachbit）释放磁盘空间，通过释放缓<br>存、删除cookie、清除上网记录、粉碎临时文件、删除日志，以及丢弃<br>其他一些非必需的文件来提高隐私性。使用高级技术，包括粉碎文件来<br>防止恢复，擦除空闲磁盘空间来隐藏没有完全删除的文件的踪迹。</p><p>~/.config/deepin/deepin-terminal/config.conf</p><h3 id="执行命令">执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo apt-get update<br>sudo apt-get upgrade<br></code></pre></td></tr></table></figure><h2 id="配置VIM">配置VIM</h2><h3 id="打开终端，执行命令">打开终端，执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo gedit &#x2F;etc&#x2F;hosts<br></code></pre></td></tr></table></figure><h3 id="将以下两行文本添加到文本框中，保存并退出">将以下两行文本添加到文本框中，保存并退出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">192.30.255.112 github.com git<br>185.31.16.184 github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure><h3 id="执行命令-2">执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo wget -qO- https:&#x2F;&#x2F;raw.github.com&#x2F;ma6174&#x2F;vim&#x2F;master&#x2F;setup.sh | sh -x<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/LSG_Down/article/details/89319472">https://blog.csdn.net/LSG_Down/article/details/89319472</a></p><p><a href="https://www.jianshu.com/p/75cde8a80fd7">https://www.jianshu.com/p/75cde8a80fd7</a></p><h2 id="安装sshpi及scppi">安装sshpi及scppi</h2><p>sshpi.sh参考代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br><br>#文件名：sshpi.sh<br>#用途：远程连接树莓派<br><br>function Usage() &#123;<br>echo &quot;Usage: sshpi Username@pi&quot;<br>echo &quot;Like This：sshpi UserA@pi1&quot;<br>&#125;<br>if [[ ! $# -eq 1  ]]; then<br>Usage<br>exit<br>fi<br><br>echo $1 | grep &quot;@&quot; &gt;&#x2F;dev&#x2F;zero 2&gt;&amp;1<br><br>if [[ ! $? -eq 0 ]]; then<br>echo &quot;argument wrong！&quot;<br>Usage<br>exit<br>fi<br>Username&#x3D;&#96;echo $1 | cut -d &quot;@&quot; -f 1&#96;<br>if [[ $&#123;Username&#125;x &#x3D;&#x3D; x ]]; then<br>echo &quot;Please input your username!&quot;<br>Usage<br>exit<br>fi<br>Hostname&#x3D;&#96;echo $1 | cut -d &quot;@&quot; -f 2&#96;<br>if [[ $&#123;Hostname&#125;x &#x3D;&#x3D; x ]]; then<br>echo &quot;Please input Hostname of Pi!&quot;<br>Usage<br>exit<br>fi<br>echo $Hostname | grep -w &quot;^pi[1-9][0-9]\?&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<br>if [[ ! $? -eq 0 ]]; then<br>echo &quot;Hostname is Wrong!&quot;<br>Usage<br>exit<br>fi<br>HostNum&#x3D;&#96;echo $Hostname | cut -c 3-&#96;<br>if [[ $HostNum -gt 22 ]]; then<br>echo &quot;Hostname is Wrong!&quot;<br>Usage<br>exit<br>fi<br><br>port&#x3D;$[6530 + $HostNum]<br>echo -e &quot;\033[46;30m You Will login\033[0m\033[46;31m $Hostname\033[0m\033[46;30m with Username \033[46;31m$Username\033[0m\033[46;30m, enjoy it!\033[0m&quot;<br>ssh -p $port $&#123;Username&#125;@zentao.haizeix.tech<br></code></pre></td></tr></table></figure><p>scppi.sh参考代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br><br>#文件名：scppi.sh<br>#用途：远程拷贝文件，在树莓派和本机之间<br><br>function Usage() &#123;<br>echo &quot;Usage: scppi file_or_dir Username@piname:dest_file_or_dir&quot;<br>echo &quot;       scppi Username@piname:.&#x2F;file_or_dir  file_or_dir&quot;<br>echo &quot;Like This：scppi PiHealth pi@pi1:.&#x2F;new&quot;<br>&#125;<br>if [[ ! $# -eq 2  ]]; then<br>Usage<br>exit<br>fi<br>#1.源<br>#2.目标<br><br>echo $1 | grep -q &quot;@&quot;<br><br>if [[ $? -eq 0 ]]; then<br>remote&#x3D;$1<br>local&#x3D;$2<br>else<br>remote&#x3D;$2<br>local&#x3D;$1<br>fi<br><br>echo $remote | grep @ | grep : &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<br>if [[ ! $? -eq 0 ]]; then<br>echo &quot;argument wrong！&quot;<br>Usage<br>exit<br>fi<br>Username&#x3D;&#96;echo $remote | cut -d &quot;@&quot; -f 1&#96;<br>if [[ $&#123;Username&#125;x &#x3D;&#x3D; x ]]; then<br>echo &quot;Please input your username!&quot;<br>Usage<br>exit<br>fi<br>Hostname&#x3D;&#96;echo $remote | cut -d &quot;@&quot; -f 2 | cut -d &quot;:&quot; -f 1&#96;<br>if [[ $&#123;Hostname&#125;x &#x3D;&#x3D; x ]]; then<br>echo &quot;Please input Hostname of Pi!&quot;<br>Usage<br>exit<br>fi<br>echo $Hostname | grep -w &quot;^pi[1-9][0-9]\?&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<br>if [[ ! $? -eq 0 ]]; then<br>echo &quot;Hostname is Wrong!&quot;<br>Usage<br>exit<br>fi<br>dir_file&#x3D;&#96;echo $remote | cut -d &quot;@&quot; -f 2 | cut -d &quot;:&quot; -f 2&#96;<br>if [[ $&#123;dir_file&#125;x &#x3D;&#x3D; x ]]; then<br>echo &quot;Please input dest_file_or_dir of Pi!&quot;<br>Usage<br>exit<br>fi<br><br>HostNum&#x3D;&#96;echo $Hostname | cut -c 3-&#96;<br><br>if [[ $HostNum -gt 22 ]]; then<br>echo &quot;Hostname is Wrong!&quot;<br>Usage<br>exit<br>fi<br><br>port&#x3D;$[6530 + $HostNum]<br>echo -e &quot;\033[46;30m Coping \033[46;31m$1\033[46;30m to \033[46;31m$dir_file\033[46;30m on \033[46;31m$Hostname\033[46;30m with Username \033[46;31m$Username\033[46;30m, enjoy it!\033[0m&quot;<br><br>if [[ $1 &#x3D; $local ]]; then<br>scp -P $port -r $1  $&#123;Username&#125;@zentao.haizeix.tech:$dir_file<br>else<br>scp -P $port -r $&#123;Username&#125;@zentao.haizeix.tech:$dir_file $local<br>fi<br></code></pre></td></tr></table></figure><h3 id="打开终端，执行命令-2">打开终端，执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">vim sshpi.sh<br></code></pre></td></tr></table></figure><h3 id="在VIM文本框里粘贴sshpi脚本的代码，保存并退出（：wq）">在VIM文本框里粘贴sshpi脚本的代码，保存并退出（：wq）</h3><h3 id="将sshpi-sh重命名为sshpi-赋予sshpi脚本可执行权限">将sshpi.sh重命名为sshpi,赋予sshpi脚本可执行权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">mv sshpi.sh sshpi<br>chmod a+x sshpi<br></code></pre></td></tr></table></figure><h3 id="执行命令-3">执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">echo $PATH<br></code></pre></td></tr></table></figure><h3 id="将sshpi复制到PATH路径下">将sshpi复制到PATH路径下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cp sshpi &#x2F;bin<br></code></pre></td></tr></table></figure><h3 id="同样的操作生成scppi脚本">同样的操作生成scppi脚本</h3><h1>DAY02</h1><h2 id="设置免密登录">设置免密登录</h2><h3 id="打开终端，执行命令-3">打开终端，执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sshpi lws@pi3<br></code></pre></td></tr></table></figure><p>暂时需要密码（haizei）来连接树莓派</p><h3 id="在本机生成秘钥">在本机生成秘钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ssh-keygen<br></code></pre></td></tr></table></figure><h3 id="将秘钥复制到authorized-keys文件中">将秘钥复制到authorized_keys文件中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cat .ssh&#x2F;id_rsa.pub&gt;&gt;.ssh&#x2F;authorized_keys<br></code></pre></td></tr></table></figure><h3 id="将本机的authorized-keys文件复制到树莓派中">将本机的authorized_keys文件复制到树莓派中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">scppi .ssh&#x2F;authorized_keys lws@pi3:&#x2F;.ssh<br></code></pre></td></tr></table></figure><h3 id="再次连接树莓派，验证是否成功">再次连接树莓派，验证是否成功</h3><p>check.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include &lt;stdio.h&gt;<br>#include &lt;sys&#x2F;socket.h&gt;<br>#include &lt;sys&#x2F;types.h&gt;<br>#include &lt;arpa&#x2F;inet.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;pwd.h&gt;<br><br>int socket_connect(int port, char *host) &#123;<br>int sockfd;<br>struct sockaddr_in dest_addr;<br>if ((sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123;<br>perror(&quot;socket() error&quot;);<br>return -1;<br>&#125;<br><br>memset(&amp;dest_addr, 0, sizeof(dest_addr));<br>dest_addr.sin_family &#x3D; AF_INET;<br>dest_addr.sin_port &#x3D; htons(port);<br>dest_addr.sin_addr.s_addr &#x3D; inet_addr(host);<br><br>if (connect(sockfd, (struct sockaddr *)&amp;dest_addr, sizeof(dest_addr)) &lt; 0) &#123;<br>perror(&quot;connect() error&quot;);<br>return -1;<br>&#125;<br>return sockfd;<br><br>&#125;<br><br>int main() &#123;<br>int  socket_fd;<br>struct passwd *pwd;<br>pwd &#x3D; getpwuid(getuid());<br>char ip_addr[20] &#x3D; &quot;192.168.1.40&quot;;<br>int port &#x3D; 8888;<br>char username[20] &#x3D; &#123;0&#125;;<br>strcpy(username, pwd-&gt;pw_name);<br>socket_fd &#x3D; socket_connect(port, ip_addr);<br>if (socket_fd &lt; 0)<br>&#123;<br>exit(1);<br>&#125;<br>if (send(socket_fd, username, strlen(username), 0) &gt; 0) &#123;<br>printf(&quot;Check Success\n&quot;);<br>&#125; <br>close(socket_fd);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>gcc check.c -o check</p><h2 id="VIM的简单使用">VIM的简单使用</h2><p><img src="https://ese3a9b6c5d0ic.prissl.qiqiuyun.net/course-activity-272/20190411093248-lntidnybu9wksckc/53eb89158008bece_img3?e=1563481633&amp;token=ExRD5wolmUnwwITVeSEXDQXizfxTRp7vnaMKJbO-:CAFs0zlzq99uvJ2s6B6SYjVIbcI=" alt="img"></p><h3 id="VIM的四种模式">VIM的四种模式</h3><h3 id="普通模式">普通模式</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x d dd ndd dw d$ d^ dG dnG</td><td>删除说明</td></tr><tr><td>y yy yG ynG y$ y^</td><td>复制</td></tr><tr><td>p P</td><td>粘贴</td></tr><tr><td>gg GG ngg</td><td>移动光标</td></tr><tr><td>R cc cG cnG c$ c^</td><td>替换</td></tr><tr><td>u ctrl+r ctrl+v</td><td>undo redo 可视块操作</td></tr></tbody></table><h3 id="插入模式">插入模式</h3><table><thead><tr><th>i</th><th>在光标之前追加</th></tr></thead><tbody><tr><td>a</td><td>在光标之后追加</td></tr><tr><td>A</td><td>在一行的结尾处追加</td></tr><tr><td>I</td><td>在一行的开头处插入</td></tr><tr><td>o</td><td>在光标所在位置的下一行打开新行插入</td></tr><tr><td>O</td><td>在光标所在位置的上一行打开新行插入</td></tr></tbody></table><h3 id="命令模式">命令模式</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:w :q :wq :x :wq! :q!</td><td>文件的保存与退出操作</td></tr><tr><td>:args</td><td>显示文件名称，切换文件</td></tr><tr><td>:e foo.txt</td><td>打开foo.txt</td></tr><tr><td>:saveas ~/foo.txt</td><td>另存为~/foo.txt</td></tr><tr><td>:split :vsplit</td><td>切分窗口</td></tr><tr><td>:set</td><td>设置选项</td></tr></tbody></table><h3 id="其他使用技巧">其他使用技巧</h3><table><thead><tr><th>Ctrl+z</th><th>挂起</th></tr></thead><tbody><tr><td>fg</td><td>返回前台</td></tr><tr><td>/findstring</td><td>查找</td></tr></tbody></table><h2 id="Python的升级与tldr的升级">Python的升级与tldr的升级</h2><h3 id="打开终端，执行命令-4">打开终端，执行命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo apt-get install python<br>sudo apt-get install python3<br></code></pre></td></tr></table></figure><h3 id="查看Python版本">查看Python版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">python -V<br>python3 -V<br></code></pre></td></tr></table></figure><h3 id="获取Python路径">获取Python路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">which python<br></code></pre></td></tr></table></figure><h3 id="查看Python">查看Python</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ls -al &#x2F;usr&#x2F;bin&#x2F;python<br></code></pre></td></tr></table></figure><h3 id="强制删除Python，将Python3-5指向Python">强制删除Python，将Python3.5指向Python</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo rm &#x2F;usr&#x2F;bin&#x2F;python<br>sudo ln &#x2F;usr&#x2F;bin&#x2F;python3.5 &#x2F;usr&#x2F;bin&#x2F;python<br></code></pre></td></tr></table></figure><h3 id="安装pyhton3-pip">安装pyhton3-pip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo apt-get insatll python3-pip<br></code></pre></td></tr></table></figure><h3 id="升级pip">升级pip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">pip install --upgrade pip<br></code></pre></td></tr></table></figure><h3 id="pip3-list报错，解决">pip3 list报错，解决</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo vim &#x2F;usr&#x2F;bin&#x2F;pip3<br></code></pre></td></tr></table></figure><p>在文本框中pip后加上._internal</p><h3 id="安装tldr">安装tldr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo pip install tldr<br></code></pre></td></tr></table></figure><h2 id="Linux极简入门">Linux极简入门</h2><h3 id="软件的安装与卸载">软件的安装与卸载</h3><ul><li>apt-get update</li><li>apt-get upgrade</li><li>apt-get install xxx</li><li>apt-get --purge remove xxx</li><li>apt-cache search xxx</li></ul><h3 id="目录">目录</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cd</td><td>切换当前目录</td></tr><tr><td>pwd</td><td>打印当期目录工作</td></tr><tr><td>mkdir</td><td>创建目录</td></tr></tbody></table><h3 id="cd切换工作">cd切换工作</h3><ul><li><p>cd /etc直接切换到/etc目录</p><p>cd …切换到上层目录</p><p>cd .切换到当前目录</p><p>cd回到自己的家目录</p><p>cd ~回到自己的家目录</p><p>cd -回到上次工作目录</p></li></ul><h3 id="pwd打印当前工作目录">pwd打印当前工作目录</h3><p>pwd [-LP]</p><ul><li>-L显示逻辑工作目录<br>-P显示物理工作目录</li></ul><h3 id="mkdir创建目录">mkdir创建目录</h3><p>mkdir [-pm] <dir></p><ul><li><p>-p自动创建父目录</p><p>-m设置权限</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DAY01&lt;/h1&gt;
&lt;h2 id=&quot;更新源&quot;&gt;更新源&lt;/h2&gt;
&lt;h3 id=&quot;打开终端（Ctrl-Alt-T），执行命令&quot;&gt;打开终端（Ctrl+Alt+T），执行命令&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Newcoder_cpp</title>
    <link href="https://lwscode.cn/p/22684/"/>
    <id>https://lwscode.cn/p/22684/</id>
    <published>2021-04-20T02:58:13.000Z</published>
    <updated>2021-04-26T11:15:10.711Z</updated>
    
    <content type="html"><![CDATA[<h1>niuke interview</h1><h2 id="基本语言">基本语言</h2><h3 id="请说一下C-C-中指针和引用的区别？">请说一下C/C++ 中指针和引用的区别？</h3><p>参考回答：</p><ol><li><p>指针有自己的一块空间，而引用只是一个别名；</p></li><li><p>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p></li><li><p>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</p></li><li><p>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</p></li><li><p>可以有const指针，但是没有const引用；</p></li><li><p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p></li><li><p>指针可以有多级指针（**p），而引用至于一级；</p></li><li><p>指针和引用使用++运算符的意义不一样；</p></li><li><p>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p></li></ol><h3 id="请你回答一下野指针是什么？">请你回答一下野指针是什么？</h3><p>参考回答：</p><p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;niuke interview&lt;/h1&gt;
&lt;h2 id=&quot;基本语言&quot;&gt;基本语言&lt;/h2&gt;
&lt;h3 id=&quot;请说一下C-C-中指针和引用的区别？&quot;&gt;请说一下C/C++ 中指针和引用的区别？&lt;/h3&gt;
&lt;p&gt;参考回答：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;指针有自己的一块空间，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Manjaro Kde安装后的配置</title>
    <link href="https://lwscode.cn/p/9628/"/>
    <id>https://lwscode.cn/p/9628/</id>
    <published>2021-04-20T02:55:45.000Z</published>
    <updated>2021-04-26T11:15:10.711Z</updated>
    
    <content type="html"><![CDATA[<h1>manjaro kde安装后的配置</h1><h2 id="启动项">启动项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-grub<br></code></pre></td></tr></table></figure><h2 id="镜像源（选择清华源）">镜像源（选择清华源）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman-mirrors -i -c China -m rank<br>sudo pacman -Syy<br>sudo nano /etc/pacman.conf<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">[archlinuxcn]<br>SigLevel &#x3D; Optional TrustedOnly<br>Server &#x3D; http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;archlinuxcn&#x2F;$arch<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S archlinuxcn-keyring<br>sudo apcman -Syyu<br></code></pre></td></tr></table></figure><h2 id="安装软件">安装软件</h2><h3 id="yay">yay</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S yay base-devel<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay --save --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot;<br></code></pre></td></tr></table></figure><h3 id="git">git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S git<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &#x27;lws597&#x27;<br>git config --global user.email &#x27;1320949958@qq.com&#x27;<br>sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">52.74.223.119 github.com<br>151.101.77.194 github.global.ssl.fastly.net<br>151.101.76.133 raw.githubusercontent.com<br></code></pre></td></tr></table></figure><h4 id="github密钥导入">github密钥导入</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen<br>cat .ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><h3 id="常用">常用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S gcc go jdk8-openjdk clang python python2 google-chrome netease-cloud-music typora<br></code></pre></td></tr></table></figure><h3 id="pip">pip</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S python-pip python2-pip<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/.pip<br>nano ~/.pip/pip.conf<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">[global]<br>index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple<br>[install]<br>trusted-host &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn<br></code></pre></td></tr></table></figure><h3 id="npm">npm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config set registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h3 id="neovim">neovim</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -Rns vim<br>yay -S neovim<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd .config<br>git clone git://github.com/lws597/nvim<br></code></pre></td></tr></table></figure><h3 id="zsh">zsh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S zsh<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;<br></code></pre></td></tr></table></figure><h4 id="zsh插件">zsh插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">plugins&#x3D;(git zsh-autosuggestions zsh-syntax-highlighting autojump web-search extract last-working-dir sudo pip thefuck colored-man-pages colorize safe-paste git-open vi-mode copyfile copydir gitfast command-not-found history)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S autojump thefuck<br>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting<br>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions<br>git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open<br></code></pre></td></tr></table></figure><h4 id="zshrc添加">zshrc添加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">alias vim&#x3D;&quot;nvim&quot;<br>alias vi&#x3D;&quot;nvim&quot;<br>alias rm&#x3D;&quot;rm -i&quot;<br>alias cp&#x3D;&quot;cp -i&quot;<br>alias cls&#x3D;&quot;clear&quot;<br>alias cat&#x3D;&quot;ccat&quot;<br>alias ra&#x3D;&quot;ranger&quot;<br>alias -s c&#x3D;copyfile<br>alias -s cpp&#x3D;copyfile<br></code></pre></td></tr></table></figure><h3 id="输入法（rime）">输入法（rime）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S fcitx-im kcm-fcitx fcitx-rime<br>sudo vim ~/.xprofile<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">export GTK_IM_MODULE&#x3D;fcitx<br>export QT_IM_MODULE&#x3D;fcitx<br>export XMODIFIERS&#x3D;&quot;&quot;@im&#x3D;fcitx&quot;<br></code></pre></td></tr></table></figure><h3 id="wps">wps</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S wps-office-mui-zh-cn wps-office ttf-wps-fonts<br></code></pre></td></tr></table></figure><h3 id="IDE">IDE</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S visual-studio-code-bin<br></code></pre></td></tr></table></figure><h3 id="字体">字体</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S nerd-fonts-complete ttf-monaco ttf-hanazono<br></code></pre></td></tr></table></figure><h3 id="美化">美化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S latte-dock<br></code></pre></td></tr></table></figure><p>主题arc</p><p>图标numix papirus</p><p>光标mcmojave</p><h3 id="其他软件">其他软件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S xmind zoom dingtalk electronic-wechat qq-linux<br></code></pre></td></tr></table></figure><h3 id="双系统时间">双系统时间</h3><p>windows端管理员下cmd或powershell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">reg add &quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_QWORD /f<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;manjaro kde安装后的配置&lt;/h1&gt;
&lt;h2 id=&quot;启动项&quot;&gt;启动项&lt;/h2&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git代理</title>
    <link href="https://lwscode.cn/p/39017/"/>
    <id>https://lwscode.cn/p/39017/</id>
    <published>2021-04-20T02:54:04.000Z</published>
    <updated>2021-04-26T11:15:10.710Z</updated>
    
    <content type="html"><![CDATA[<h1>git设置和取消代理</h1><h2 id="设置如下：">设置如下：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global https.proxy http://127.0.0.1:1080<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global https.proxy https://127.0.0.1:1080<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span> <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global https.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1080&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="取消">取消</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;git设置和取消代理&lt;/h1&gt;
&lt;h2 id=&quot;设置如下：&quot;&gt;设置如下：&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Effective</title>
    <link href="https://lwscode.cn/p/52590/"/>
    <id>https://lwscode.cn/p/52590/</id>
    <published>2021-04-20T02:50:31.000Z</published>
    <updated>2021-04-26T11:15:10.710Z</updated>
    
    <content type="html"><![CDATA[<h1>Interview Q&amp;A</h1><h2 id="Effective-C">Effective C++</h2><ol><li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</li><li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</li><li>尽可能使用 const</li><li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</li><li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）</li><li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）</li><li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）</li><li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）</li><li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）</li><li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）</li><li>在 <code>operator=</code> 中处理 “自我赋值”</li><li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）</li><li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））</li><li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））</li><li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）</li><li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）</li><li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）</li><li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）</li><li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。</li><li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）</li><li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）</li><li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）</li><li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</li><li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数</li><li>考虑写一个不抛异常的 swap 函数</li><li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）</li><li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&lt;T&gt;(expression)</code>、<code>dynamic_cast&lt;T&gt;(expression)</code>、<code>reinterpret_cast&lt;T&gt;(expression)</code>、<code>static_cast&lt;T&gt;(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）</li><li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）</li><li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）</li><li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）</li><li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）</li><li>确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）</li><li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）</li><li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）</li><li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）</li><li>绝不重新定义继承而来的 non-virtual 函数</li><li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）</li><li>通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））</li><li>明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）</li><li>明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）</li><li>了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）</li><li>了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）</li><li>学习处理模板化基类内的名称（可在 derived class templates 内通过 <code>this-&gt;</code> 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）</li><li>将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）</li><li>运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）</li><li>需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）</li><li>请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if…else 测试）</li><li>认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）</li><li>了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）</li><li>了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）</li><li>编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）</li><li>写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）</li><li>不要轻忽编译器的警告</li><li>让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）</li><li>让自己熟悉 Boost（准标准库）</li></ol><h2 id="More-Effective-c">More Effective c++</h2><ol><li>仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）</li><li>最好使用 C++ 转型操作符（<code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>）</li><li>绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）</li><li>非必要不提供 default constructor（避免对象中的字段被无意义地初始化）</li><li>对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）</li><li>区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）</li><li>千万不要重载 <code>&amp;&amp;</code>，<code>||</code> 和 <code>,</code> 操作符（<code>&amp;&amp;</code> 与 <code>||</code> 的重载会用 “函数调用语义” 取代 “骤死式语义”；<code>,</code> 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）</li><li>了解各种不同意义的 new 和 delete（<code>new operator</code>、<code>operator new</code>、<code>placement new</code>、<code>operator new[]</code>；<code>delete operator</code>、<code>operator delete</code>、<code>destructor</code>、<code>operator delete[]</code>）</li><li>利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）</li><li>在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try…catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）</li><li>禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）</li><li>了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）</li><li>以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）</li><li>明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）</li><li>了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）</li><li>谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）</li><li>考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）</li><li>分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Interview Q&amp;amp;A&lt;/h1&gt;
&lt;h2 id=&quot;Effective-C&quot;&gt;Effective C++&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）&lt;/li&gt;
&lt;li&gt;宁</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cpp_stl</title>
    <link href="https://lwscode.cn/p/56828/"/>
    <id>https://lwscode.cn/p/56828/</id>
    <published>2021-04-20T02:48:16.000Z</published>
    <updated>2021-04-26T11:15:10.710Z</updated>
    
    <content type="html"><![CDATA[<h1>c++ stl</h1><h2 id="queue-类说明">queue-类说明</h2><p>queue类：队列</p><ul><li>头文件：queue</li><li>命名空间：std</li><li>声明：queue&lt;data_type&gt; q;</li></ul><table><thead><tr><th style="text-align:left">q.fornt()</th><th>查看队首元素</th></tr></thead><tbody><tr><td style="text-align:left">q.empty()</td><td>队列判空</td></tr><tr><td style="text-align:left">q.push()</td><td>入队</td></tr><tr><td style="text-align:left">q.pop()</td><td>出队</td></tr><tr><td style="text-align:left">q.size()</td><td>队列元素数量</td></tr></tbody></table><h2 id="stack-类说明">stack-类说明</h2><p>stack类：栈</p><ul><li>头文件：stack</li><li>命名空间：std</li><li>声明：stack&lt;data_type&gt; s;</li></ul><table><thead><tr><th>s.top()</th><th>查看栈顶元素</th></tr></thead><tbody><tr><td>s.empty()</td><td>栈判空</td></tr><tr><td>s.push()</td><td>入栈</td></tr><tr><td>s.pop()类</td><td>出栈</td></tr><tr><td>s.size()</td><td>栈元素数量</td></tr></tbody></table><h2 id="string-类说明">string-类说明</h2><p>string类：字符串</p><ul><li>头文件：string</li><li>命名空间：std</li><li>声明：string str1, str2;</li></ul><table><thead><tr><th>str1 == str2</th><th>字符串判等</th></tr></thead><tbody><tr><td>str1 &lt; str2</td><td>字典序小于</td></tr><tr><td>str1 &gt; str2</td><td>字典序大于</td></tr><tr><td>str1 += str2</td><td>字符串连接</td></tr><tr><td>str1.length()</td><td>字符串长度</td></tr></tbody></table><h3 id="string-hzoj-166">string (hzoj-166)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str1, str2;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; str1 &gt;&gt; n &gt;&gt; str2;<br>    cout &lt;&lt; <span class="hljs-built_in">min</span>(str1.<span class="hljs-built_in">length</span>(), (<span class="hljs-keyword">size_t</span>)<span class="hljs-number">100</span>) &lt;&lt; endl;<br>    str1.<span class="hljs-built_in">insert</span>(n - <span class="hljs-number">1</span>, str2);<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br>    cout &lt;&lt; str1.<span class="hljs-built_in">length</span>() - str1.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&#x27;x&#x27;</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hash-map-类说明">hash_map-类说明</h2><p>hash_map类：字符串</p><ul><li>头文件：&lt;hash_map&gt; / &lt;ext/hash_map&gt;</li><li>命名空间：__gnu_cxx</li><li>声明：hash_map&lt;key_type, value_type, hash_func&gt; h;</li></ul><table><thead><tr><th>h.find(key)</th><th>判断某个key值是否在hash_map中</th></tr></thead><tbody><tr><td>h[key] = value</td><td>将value存储在key位上</td></tr><tr><td>h[key]</td><td>房屋key值对应的value</td></tr><tr><td>h.begin()</td><td>哈希表的起始位置</td></tr><tr><td>h.end()</td><td>哈希表的结束位置</td></tr></tbody></table><h2 id="unordered-map-类说明（c-11标准）">unordered_map-类说明（c++11标准）</h2><p>unordered_map-类：字符串</p><ul><li>头文件：unordered_map</li><li>命名空间：std</li><li>声明：unordered_map&lt;key_type, value_type, hash_func&gt; h;</li></ul><table><thead><tr><th>h.find(key)</th><th>判断某个key值是否在unordered_map中</th></tr></thead><tbody><tr><td>h[key] = value</td><td>将value存储在key位上</td></tr><tr><td>h[key]</td><td>访问key值对应的value</td></tr><tr><td>h.begin()</td><td>哈希表的起始位置</td></tr><tr><td>h.end()</td><td>哈希表的结束位置</td></tr></tbody></table><h3 id="sort-hzoj-245">sort (hzoj-245)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 100000</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> a[max_n + <span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a, a + n);<br>    <span class="hljs-keyword">int</span> p = a[n &gt;&gt; <span class="hljs-number">1</span>], ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        ans += <span class="hljs-built_in">abs</span>(p - a[i]);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="nth-element-hzoj-245">nth_element (hzoj-245)</h3><p>nth_element是部分排序算法，它重排[first, last)中元素，使得：</p><ul><li>nth所指向的元素被更改为假如[first, last)已排序则该位置会出现的元素。</li><li>这个新的nth元素前的所有元素小于或等于新的 nth 元素后的所有元素。</li></ul><p>更正式而言，nth_element以升序部分排序范围[first, last)，使得对于任何范围[first, nth)中的i和任何范围[nth, last)中的j，都满足条件!(*j &lt; i)。置于nth位置的元素则准确地是假如完全排序范围则应出现于此位置的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 100000</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> a[max_n + <span class="hljs-number">5</span>], ind[max_n + <span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">nth_element</span>(a, a + (n &gt;&gt; <span class="hljs-number">1</span>), a + n);<br>    <span class="hljs-keyword">int</span> p = a[n &gt;&gt; <span class="hljs-number">1</span>], ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        ans += <span class="hljs-built_in">abs</span>(p - a[i]);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map">map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string name;<br>    <span class="hljs-keyword">int</span> n, age;<br>    set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    cout &lt;&lt; *s.<span class="hljs-built_in">begin</span>() &lt;&lt; endl;<br>    s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = s.<span class="hljs-built_in">begin</span>(); iter != s.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>        cout &lt;&lt; *iter &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    map&lt;<span class="hljs-keyword">int</span>, string&gt; arr;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; age &gt;&gt; name;<br>        arr[age] = name;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = arr.<span class="hljs-built_in">begin</span>(); iter != arr.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>        cout &lt;&lt; iter-&gt;second &lt;&lt; endl; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="存储任意类型的数组-vector-array">存储任意类型的数组 (vector-&gt;array)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> &#123;</span><br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-built_in">Array</span>() &#123;<br>        <span class="hljs-keyword">this</span>-&gt;__size = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">this</span>-&gt;__cnt  = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>-&gt;data = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;__size];<br>    &#125;<br>    <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;__size = <span class="hljs-number">2</span> * n;<br>        <span class="hljs-keyword">this</span>-&gt;__cnt  = n;<br>        <span class="hljs-keyword">this</span>-&gt;data = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;__size];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;a)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span>(<span class="hljs-keyword">this</span>-&gt;data + ((<span class="hljs-keyword">this</span>-&gt;__cnt)++)) <span class="hljs-built_in">T</span>(a);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;__cnt;<br>    &#125;<br>    T &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> ind) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;data[ind];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T *data;<br>    <span class="hljs-keyword">int</span> __size, __cnt;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Array&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cout &lt;&lt; arr.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">123</span>);<br>    cout &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    cout &lt;&lt; arr.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <br>    cout &lt;&lt; arr2.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    arr2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">123</span>);<br>    cout &lt;&lt; arr2[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    cout &lt;&lt; arr2.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;c++ stl&lt;/h1&gt;
&lt;h2 id=&quot;queue-类说明&quot;&gt;queue-类说明&lt;/h2&gt;
&lt;p&gt;queue类：队列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头文件：queue&lt;/li&gt;
&lt;li&gt;命名空间：std&lt;/li&gt;
&lt;li&gt;声明：queue&amp;lt;data_type&amp;gt; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Computer_networking</title>
    <link href="https://lwscode.cn/p/40772/"/>
    <id>https://lwscode.cn/p/40772/</id>
    <published>2021-04-20T02:46:58.000Z</published>
    <updated>2021-04-26T11:15:10.709Z</updated>
    
    <content type="html"><![CDATA[<h1>Interview Q&amp;A Computer Networking</h1><h2 id="数据链路层">数据链路层</h2><h3 id="广播信道">广播信道</h3><p>广播通信：</p><ul><li>硬件地址（物理地址、MAC 地址）</li><li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li><li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li><li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li></ul><h2 id="运输层">运输层</h2><h3 id="为什么客户端释放最后需要-TIME-WAIT-等待-2MSL-呢？">为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？</h3><ol><li>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li><li>防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Interview Q&amp;amp;A Computer Networking&lt;/h1&gt;
&lt;h2 id=&quot;数据链路层&quot;&gt;数据链路层&lt;/h2&gt;
&lt;h3 id=&quot;广播信道&quot;&gt;广播信道&lt;/h3&gt;
&lt;p&gt;广播通信：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件地址（物理地址、MAC 地址）&lt;/li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C/cpp</title>
    <link href="https://lwscode.cn/p/8601/"/>
    <id>https://lwscode.cn/p/8601/</id>
    <published>2021-04-20T02:45:39.000Z</published>
    <updated>2021-04-26T11:15:10.709Z</updated>
    
    <content type="html"><![CDATA[<h1>Interview Q&amp;A C/CPP</h1><h2 id="const">const</h2><p>int getValue();             // 普通成员函数</p><p>? int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值</p><p>const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变)</p><p>char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变)</p><p>? const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量</p><h2 id="pragma-pack-n">#pragma pack(n)</h2><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p><p>#pragma pack(n) 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(push)  <span class="hljs-comment">// 保存对齐状态</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(4)     <span class="hljs-comment">// 设定为 4 字节对齐</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> m1;<br>    <span class="hljs-keyword">double</span> m4;<br>    <span class="hljs-keyword">int</span> m3;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(pop)   <span class="hljs-comment">// 恢复对齐状态</span></span><br></code></pre></td></tr></table></figure><h2 id="位域">位域</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Bit mode: <span class="hljs-number">2</span>;    <span class="hljs-comment">// mode 占 2 位</span><br></code></pre></td></tr></table></figure><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li></ul><h2 id="explicit（显式）关键字">explicit（显式）关键字</h2><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外</li></ul><p>explicit 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span>) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doA</span><span class="hljs-params">(A a)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doB</span><span class="hljs-params">(B b)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;        <span class="hljs-comment">// OK：直接初始化</span><br>    A a2 = <span class="hljs-number">1</span>;        <span class="hljs-comment">// OK：复制初始化</span><br>    A a3&#123; <span class="hljs-number">1</span> &#125;;        <span class="hljs-comment">// OK：直接列表初始化</span><br>    A a4 = &#123; <span class="hljs-number">1</span> &#125;;        <span class="hljs-comment">// OK：复制列表初始化</span><br>    A a5 = (A)<span class="hljs-number">1</span>;        <span class="hljs-comment">// OK：允许 static_cast 的显式转换 </span><br>    <span class="hljs-built_in">doA</span>(<span class="hljs-number">1</span>);            <span class="hljs-comment">// OK：允许从 int 到 A 的隐式转换</span><br>    <span class="hljs-keyword">if</span> (a1);        <span class="hljs-comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span><br>    <span class="hljs-keyword">bool</span> a6（a1）;        <span class="hljs-comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span><br>    <span class="hljs-keyword">bool</span> a7 = a1;        <span class="hljs-comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span><br>    <span class="hljs-keyword">bool</span> a8 = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">bool</span>&gt;(a1);  <span class="hljs-comment">// OK ：static_cast 进行直接初始化</span><br><br>    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;        <span class="hljs-comment">// OK：直接初始化</span><br>    B b2 = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span><br>    B b3&#123; <span class="hljs-number">1</span> &#125;;        <span class="hljs-comment">// OK：直接列表初始化</span><br>    B b4 = &#123; <span class="hljs-number">1</span> &#125;;        <span class="hljs-comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span><br>    B b5 = (B)<span class="hljs-number">1</span>;        <span class="hljs-comment">// OK：允许 static_cast 的显式转换</span><br>    <span class="hljs-built_in">doB</span>(<span class="hljs-number">1</span>);            <span class="hljs-comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span><br>    <span class="hljs-keyword">if</span> (b1);        <span class="hljs-comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">b6</span><span class="hljs-params">(b1)</span></span>;        <span class="hljs-comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span><br>    <span class="hljs-keyword">bool</span> b7 = b1;        <span class="hljs-comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span><br>    <span class="hljs-keyword">bool</span> b8 = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">bool</span>&gt;(b1);  <span class="hljs-comment">// OK：static_cast 进行直接初始化</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-实现-C-类decltype">C 实现 C++ 类decltype</h2><p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p><ul><li>封装：使用函数指针把属性与方法封装到结构体中</li><li>继承：结构体嵌套</li><li>多态：父类与子类方法的函数指针不同</li></ul><h2 id="构造函数的-using-声明">构造函数的 using 声明</h2><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::Base;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Derived</span>(parms) : <span class="hljs-built_in">Base</span>(args) &#123; &#125;<br></code></pre></td></tr></table></figure><h2 id="enum-枚举类型">enum 枚举类型</h2><h3 id="限定作用域的枚举类型">限定作用域的枚举类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">open_modes</span> &#123;</span> input, output, append &#125;;<br></code></pre></td></tr></table></figure><h3 id="不限定作用域的枚举类型">不限定作用域的枚举类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">color</span> &#123;</span> red, yellow, green &#125;;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> floatPrec = <span class="hljs-number">6</span>, doublePrec = <span class="hljs-number">10</span> &#125;;<br></code></pre></td></tr></table></figure><h2 id="decltype">decltype</h2><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span> ( expression )<br></code></pre></td></tr></table></figure><p>decltype 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 尾置返回允许我们在参数列表之后声明返回类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br>auto fcn(It beg, It end) -&gt; decltype(*beg)<br>&#123;<br>    <span class="hljs-comment">// 处理序列</span><br>    <span class="hljs-keyword">return</span> *beg;    <span class="hljs-comment">// 返回序列中一个元素的引用</span><br>&#125;<br><span class="hljs-comment">// 为了使用模板参数成员，必须用 typename</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br>auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type<br>&#123;<br>    <span class="hljs-comment">// 处理序列</span><br>    <span class="hljs-keyword">return</span> *beg;    <span class="hljs-comment">// 返回序列中一个元素的拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用折叠">引用折叠</h2><ul><li>X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp;</li><li>X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp;</li></ul><h2 id="initializer-list-列表初始化">initializer_list 列表初始化</h2><p>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数.</p><p>initializer_list 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;initializer_list&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> &#123;</span><br>    std::vector&lt;T&gt; v;<br>    <span class="hljs-built_in">S</span>(std::initializer_list&lt;T&gt; l) : <span class="hljs-built_in">v</span>(l) &#123;<br>         std::cout &lt;&lt; <span class="hljs-string">&quot;constructed with a &quot;</span> &lt;&lt; l.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;-element list\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(std::initializer_list&lt;T&gt; l)</span> </span>&#123;<br>        v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">end</span>(), l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    std::pair&lt;const T*, std::size_t&gt; c_arr() const &#123;<br>        <span class="hljs-keyword">return</span> &#123;&amp;v[<span class="hljs-number">0</span>], v.<span class="hljs-built_in">size</span>()&#125;;  <span class="hljs-comment">// 在 return 语句中复制列表初始化</span><br>                                   <span class="hljs-comment">// 这不使用 std::initializer_list</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">templated_fn</span><span class="hljs-params">(T)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    S&lt;<span class="hljs-keyword">int</span>&gt; s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 复制初始化</span><br>    s.<span class="hljs-built_in">append</span>(&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;);      <span class="hljs-comment">// 函数调用中的列表初始化</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The vector size is now &quot;</span> &lt;&lt; s.<span class="hljs-built_in">c_arr</span>().second &lt;&lt; <span class="hljs-string">&quot; ints:\n&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : s.v)<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Range-for over brace-init-list: \n&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-3</span>&#125;) <span class="hljs-comment">// auto 的规则令此带范围 for 工作</span><br>        std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">auto</span> al = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;   <span class="hljs-comment">// auto 的特殊规则</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The list bound to auto has size() = &quot;</span> &lt;&lt; al.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br><span class="hljs-comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span><br>                             <span class="hljs-comment">// 它无类型，故 T 无法推导</span><br>    templated_fn&lt;std::initializer_list&lt;<span class="hljs-keyword">int</span>&gt;&gt;(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;); <span class="hljs-comment">// OK</span><br>    templated_fn&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);           <span class="hljs-comment">// 也 OK</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定位-new">定位 new</h2><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">new</span> (place_address) type<br><span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (place_address) <span class="hljs-built_in">type</span> (initializers)<br><span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (place_address) type [size]<br><span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (place_address) type [size] &#123; braced initializer list &#125;<br></code></pre></td></tr></table></figure><ul><li><code>place_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul><h2 id="运行时类型信息-RTTI">运行时类型信息 (RTTI)</h2><h3 id="dynamic-cast">dynamic_cast</h3><ul><li>用于多态类型的转换</li></ul><h3 id="typeid">typeid</h3><ul><li>typeid 运算符允许在运行时确定对象的类型</li><li>type_id 返回一个 type_info 对象的引用</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li><li>只能获取对象的实际类型</li></ul><h3 id="type-info">type_info</h3><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li><li>头文件：typeinfo</li></ul><p>typeid、type_info 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flyable</span>                       // 能飞的</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeoff</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 起飞</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-comment">// 降落</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span> :</span> <span class="hljs-keyword">public</span> Flyable         <span class="hljs-comment">// 鸟</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foraging</span><span class="hljs-params">()</span> </span>&#123;...&#125;           <span class="hljs-comment">// 觅食</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeoff</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Bird</span>()&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plane</span> :</span> <span class="hljs-keyword">public</span> Flyable        <span class="hljs-comment">// 飞机</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">carry</span><span class="hljs-params">()</span> </span>&#123;...&#125;              <span class="hljs-comment">// 运输</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeoff</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type_info</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-keyword">const</span> type_info &amp; rhs) <span class="hljs-keyword">const</span>;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-keyword">const</span> type_info &amp; rhs) <span class="hljs-keyword">const</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">before</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_info &amp; rhs)</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">type_info</span>();<br><span class="hljs-keyword">private</span>:<br>    ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(Flyable *obj)</span>                 <span class="hljs-comment">// 做些事情</span></span><br><span class="hljs-function"></span>&#123;<br>    obj-&gt;<span class="hljs-built_in">takeoff</span>();<br><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(*obj).<span class="hljs-built_in">name</span>() &lt;&lt; endl;        <span class="hljs-comment">// 输出传入对象类型（&quot;class Bird&quot; or &quot;class Plane&quot;）</span><br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(*obj) == <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(Bird))            <span class="hljs-comment">// 判断对象类型</span><br>    &#123;<br>        Bird *bird = <span class="hljs-keyword">dynamic_cast</span>&lt;Bird *&gt;(obj); <span class="hljs-comment">// 对象转化</span><br>        bird-&gt;foraging();<br>    &#125;<br><br>    obj-&gt;<span class="hljs-built_in">land</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Bird *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bird</span>();<br>    <span class="hljs-built_in">doSomething</span>(b);<br>    <span class="hljs-keyword">delete</span> b;<br>    b = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Interview Q&amp;amp;A C/CPP&lt;/h1&gt;
&lt;h2 id=&quot;const&quot;&gt;const&lt;/h2&gt;
&lt;p&gt;int getValue();             // 普通成员函数&lt;/p&gt;
&lt;p&gt;? int getValue() const;       // </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>后端开发面试题</title>
    <link href="https://lwscode.cn/p/23809/"/>
    <id>https://lwscode.cn/p/23809/</id>
    <published>2021-04-20T02:43:03.000Z</published>
    <updated>2021-04-26T11:15:10.713Z</updated>
    
    <content type="html"><![CDATA[<h1>后端开发面试题</h1><h1>后端开发面试知识点大纲：</h1><h2 id="语言类（C-）：">语言类（C++）：</h2><h3 id="关键字作用解释：">关键字作用解释：</h3><p>volatile作用</p><pre><code>Volatile关键词的第一个特性：易变性。所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。Volatile关键词的第二个特性：“不可优化”特性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。Volatile关键词的第三个特性：”顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。C/C++ Volatile变量，与非Volatile变量之间的操作，是可能被编译器交换顺序的。C/C++ Volatile变量间的操作，是不会被编译器交换顺序的。哪怕将所有的变量全部都声明为volatile，哪怕杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力针对这个多线程的应用，真正正确的做法，是构建一个happens-before语义。[C/C++ Volatile关键词深度剖析](http://hedengcheng.com/?p=725)</code></pre><p>static</p><pre><code>控制变量的存储方式和可见性。 (1)修饰局部变量一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。(2)修饰全局变量对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。(3)修饰函数用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。(4)C++中的static如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有。它们在存储空间中都只存在一个副本。可以通过类和对象去调用。</code></pre><p>const的含义及实现机制</p><pre><code> const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。 (1)const修饰基本数据类型 1.const修饰一般常量及数组   基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。    2.const修饰指针变量*及引用变量&amp;   如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。(2)const应用到函数中,   1.作为参数的const修饰符  调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。 [注意]：参数const通常用于参数为指针或引用的情况;   2.作为函数返回值的const修饰符  声明了返回值后，const按照&quot;修饰原则&quot;进行修饰，起到相应的保护作用。(3)const在类中的用法不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行类中的成员函数：A fun4()const; 其意义上是不能修改所在类的的任何变量。(4)const修饰类对象，定义常量对象 常量对象只能调用常量函数，别的成员函数都不能调用。http://www.cnblogs.com/wintergrass/archive/2011/04/15/2015020.html</code></pre><p>extern</p><pre><code>在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？因为用extern会加速程序的编译过程，这样能节省时间。在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。</code></pre><p>宏定义和展开、内联函数区别，</p><pre><code>内联函数是代码被插入到调用者代码处的函数。如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编译器优化。 宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。宏是预编译器的输入，然后宏展开之后的结果会送去编译器做语法分析。宏与函数等处于不同的级别，操作不同的实体。宏操作的是 token, 可以进行 token的替换和连接等操作，在语法分析之前起作用。而函数是语言中的概念，会在语法树中创建对应的实体，内联只是函数的一个属性。对于问题：有了函数要它们何用？答案是：一：函数并不能完全替代宏，有些宏可以在当前作用域生成一些变量，函数做不到。二：内联函数只是函数的一种，内联是给编译器的提示，告诉它最好把这个函数在被调用处展开，省掉一个函数调用的开销（压栈，跳转，返回）内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样内联函数必须是和函数体申明在一起，才有效。[宏定义和内联函数区别](http://www.cnblogs.com/chengxuyuancc/archive/2013/04/04/2999844.html)</code></pre><h3 id="库函数实现：">库函数实现：</h3><p>malloc,strcpy,strcmp的实现，常用库函数实现，哪些库函数属于高危函数</p><h3 id="STL原理及实现：">STL原理及实现：</h3><p>STL各类型容器实现，STL共有六大组件</p><p>STL提供六大组件，彼此可以组合套用：</p><pre><code>1、容器（Containers）：各种数据结构，如：序列式容器vector、list、deque、关联式容器set、map、multiset、multimap。用来存放数据。从实现的角度来看，STL容器是一种class template。2、算法（algorithms）：各种常用算法，如：sort、search、copy、erase。从实现的角度来看，STL算法是一种 function template。注意一个问题：任何的一个STL算法，都需要获得由一对迭代器所标示的区间，用来表示操作范围。这一对迭代器所标示的区间都是前闭后开区间，例如[first, last)3、迭代器（iterators）：容器与算法之间的胶合剂，是所谓的“泛型指针”。共有五种类型，以及其他衍生变化。从实现的角度来看，迭代器是一种将 operator*、operator-&gt;、operator++、operator- - 等指针相关操作进行重载的class template。所有STL容器都有自己专属的迭代器，只有容器本身才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。4、仿函数（functors）：行为类似函数，可作为算法的某种策略（policy）。从实现的角度来看，仿函数是一种重载了operator（）的class或class template。一般的函数指针也可视为狭义的仿函数。5、配接器（adapters）：一种用来修饰容器、仿函数、迭代器接口的东西。例如：STL提供的queue 和 stack，虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应。改变 functors接口者，称为function adapter；改变 container 接口者，称为container adapter；改变iterator接口者，称为iterator adapter。6、配置器（allocators）：负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。这六大组件的交互关系：container（容器） 通过 allocator（配置器） 取得数据储存空间，algorithm（算法）通过 iterator（迭代器）存取 container（容器） 内容，functor（仿函数） 可以协助 algorithm（算法） 完成不同的策略变化，adapter（配接器） 可以修饰或套接 functor（仿函数）序列式容器：vector-数组，元素不够时再重新分配内存，拷贝原来数组的元素到新分配的数组中。list－单链表。deque-分配中央控制器map(并非map容器)，map记录着一系列的固定长度的数组的地址.记住这个map仅仅保存的是数组的地址,真正的数据在数组中存放着.deque先从map中央的位置(因为双向队列，前后都可以插入元素)找到一个数组地址，向该数组中放入数据，数组不够时继续在map中找空闲的数组来存数据。当map也不够时重新分配内存当作新的map,把原来map中的内容copy的新map中。所以使用deque的复杂度要大于vector，尽量使用vector。stack-基于deque。queue-基于deque。heap-完全二叉树，使用最大堆排序，以数组(vector)的形式存放。priority_queue-基于heap。slist-双向链表。关联式容器：set,map,multiset,multimap-基于红黑树(RB-tree)，一种加上了额外平衡条件的二叉搜索树。hash table-散列表。将待存数据的key经过映射函数变成一个数组(一般是vector)的索引，例如：数据的key%数组的大小＝数组的索引(一般文本通过算法也可以转换为数字)，然后将数据当作此索引的数组元素。有些数据的key经过算法的转换可能是同一个数组的索引值(碰撞问题，可以用线性探测，二次探测来解决)，STL是用开链的方法来解决的，每一个数组的元素维护一个list，他把相同索引值的数据存入一个list，这样当list比较短时执行删除，插入，搜索等算法比较快。hash_map,hash_set,hash_multiset,hash_multimap-基于hashtable。</code></pre><p>[STL六大组件] (<a href="http://blog.csdn.net/chenguolinblog/article/details/30336805">http://blog.csdn.net/chenguolinblog/article/details/30336805</a>)<br>什么是“标准非STL容器”？</p><p>list和vector有什么区别？</p><pre><code>vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。list拥有一段不连续的内存空间，因此不支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。</code></pre><h3 id="虚函数：">虚函数：</h3><p>虚函数的作用和实现原理，什么是虚函数,有什么作用?</p><pre><code>C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。静态多态通过重载、模板来实现；动态多态就是通过本文的主角虚函数来体现的。虚函数实现原理:包括虚函数表、虚函数指针等 虚函数的作用说白了就是：当调用一个虚函数时，被执行的代码必须和调用函数的对象的动态类型相一致。编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节也不相同。大多数编译器通过vtbl（virtual table）和vptr（virtual table pointer）来实现的。 当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。vtbl实际上就是一个函数指针数组，有的编译器用的是链表，不过方法都是差不多。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址。</code></pre><p>结论：</p><pre><code>每个声明了虚函数或者继承了虚函数的类，都会有一个自己的vtbl同时该类的每个对象都会包含一个vptr去指向该vtbl虚函数按照其声明顺序放于vtbl表中, vtbl数组中的每一个元素对应一个函数指针指向该类的虚函数如果子类覆盖了父类的虚函数，将被放到了虚表中原来父类虚函数的位置在多继承的情况下，每个父类都有自己的虚表。子类的成员函数被放到了第一个父类的表中</code></pre><p>衍生问题:为什么 C++里访问虚函数比访问普通函数慢?</p><pre><code>单继承时性能差不多，多继承的时候会慢</code></pre><p>调用性能方面</p><pre><code>从前面虚函数的调用过程可知。当调用虚函数时过程如下（引自More Effective C++）:通过对象的 vptr 找到类的 vtbl。这是一个简单的操作,因为编译器知道在对象内 哪里能找到 vptr(毕竟是由编译器放置的它们)。因此这个代价只是一个偏移调整(以得到 vptr)和一个指针的间接寻址(以得到 vtbl)。找到对应 vtbl 内的指向被调用函数的指针。这也是很简单的, 因为编译器为每个虚函数在 vtbl 内分配了一个唯一的索引。这步的代价只是在 vtbl 数组内 的一个偏移。调用第二步找到的的指针所指向的函数。在单继承的情况下，调用虚函数所需的代价基本上和非虚函数效率一样，在大多数计算机上它多执行了很少的一些指令，所以有很多人一概而论说虚函数性能不行是不太科学的。在多继承的情况下，由于会根据多个父类生成多个vptr，在对象里为寻找 vptr 而进行的偏移量计算会变得复杂一些，但这些并不是虚函数的性能瓶颈。 虚函数运行时所需的代价主要是虚函数不能是内联函。这也是非常好理解的，是因为内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令，但是虚函数的“虚”是指“直到运行时才能知道要调用的是哪一个函数。”但虚函数的运行时多态特性就是要在运行时才知道具体调用哪个虚函数，所以没法在编译时进行内联函数展开。当然如果通过对象直接调用虚函数它是可以被内联，但是大多数虚函数是通过对象的指针或引用被调用的，这种调用不能被内联。 因为这种调用是标准的调用方式，所以虚函数实际上不能被内联。</code></pre><p>占用空间方面</p><pre><code>在上面的虚函数实现原理部分，可以看到为了实现运行时多态机制，编译器会给每一个包含虚函数或继承了虚函数的类自动建立一个虚函数表，所以虚函数的一个代价就是会增加类的体积。在虚函数接口较少的类中这个代价并不明显，虚函数表vtbl的体积相当于几个函数指针的体积，如果你有大量的类或者在每个类中有大量的虚函数,你会发现 vtbl 会占用大量的地址空间。但这并不是最主要的代价，主要的代价是发生在类的继承过程中，在上面的分析中，可以看到，当子类继承父类的虚函数时，子类会有自己的vtbl，如果子类只覆盖父类的一两个虚函数接口，子类vtbl的其余部分内容会与父类重复。这在如果存在大量的子类继承，且重写父类的虚函数接口只占总数的一小部分的情况下，会造成大量地址空间浪费。在一些GUI库上这种大量子类继承自同一父类且只覆盖其中一两个虚函数的情况是经常有的，这样就导致UI库的占用内存明显变大。 由于虚函数指针vptr的存在，虚函数也会增加该类的每个对象的体积。在单继承或没有继承的情况下，类的每个对象会多一个vptr指针的体积，也就是4个字节；在多继承的情况下，类的每个对象会多N个（N＝包含虚函数的父类个数）vptr的体积，也就是4N个字节。当一个类的对象体积较大时，这个代价不是很明显，但当一个类的对象很轻量的时候，如成员变量只有4个字节，那么再加上4（或4N）个字节的vptr，对象的体积相当于翻了1（或N）倍，这个代价是非常大的。</code></pre><p><a href="http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi/">C++虚函数浅析</a></p><p>纯虚函数，为什么需要纯虚函数？</p><pre><code>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”virtual void funtion1()=0原因：1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。[虚函数和纯虚函数的区别](http://blog.csdn.net/hackbuteer1/article/details/7558868)</code></pre><p>为什么需要虚析构函数,什么时候不需要?父类的析构函数为什么要定义为虚函数</p><pre><code>一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。这样做是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。</code></pre><p>内联函数、构造函数、静态成员函数可以是虚函数吗?</p><pre><code>inline, static, constructor三种函数都不能带有virtual关键字。inline是编译时展开，必须有实体；static属于class自己的，也必须有实体；virtual函数基于vtable（内存空间），constructor函数如果是virtual的，调用时也需要根据vtable寻找，但是constructor是virtual的情况下是找不到的，因为constructor自己本身都不存在了，创建不到class的实例，没有实例，class的成员（除了public static/protected static for friend class/functions，其余无论是否virtual）都不能被访问了。虚函数实际上不能被内联:虚函数运行时所需的代价主要是虚函数不能是内联函。这也是非常好理解的，是因为内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令，但是虚函数的“虚”是指“直到运行时才能知道要调用的是哪一个函数。”但虚函数的运行时多态特性就是要在运行时才知道具体调用哪个虚函数，所以没法在编译时进行内联函数展开。当然如果通过对象直接调用虚函数它是可以被内联，但是大多数虚函数是通过对象的指针或引用被调用的，这种调用不能被内联。 因为这种调用是标准的调用方式，所以虚函数实际上不能被内联。构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。 静态的对象是属于整个类的，不对某一个对象而言，同时其函数的指针存放也不同于一般的成员函数，其无法成为一个对象的虚函数的指针以实现由此带来的动态机制。</code></pre><p>构造函数中可以调用虚函数吗?</p><p>最后，总结一下关于虚函数的一些常见问题：</p><pre><code>1) 虚函数是动态绑定的，也就是说，使用虚函数的指针和引用能够正确找到实际类的对应函数，而不是执行定义类的函数。这是虚函数的基本功能，就不再解释了。 2) 构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。 3) 析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。 4) 将一个函数定义为纯虚函数，实际上是将这个类定义为抽象类，不能实例化对象。 5) 纯虚函数通常没有定义体，但也完全可以拥有。6)  析构函数可以是纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。 7) 非纯的虚函数必须有定义体，不然是一个错误。 8) 派生类的override虚函数定义必须和父类完全一致。除了一个特例，如果父类中返回值是一个指针或引用，子类override时可以返回这个指针（或引用）的派生。例如，在上面的例子中，在Base中定义了 virtual Base* clone(); 在Derived中可以定义为 virtual Derived* clone()。可以看到，这种放松对于Clone模式是非常有用的。</code></pre><p><a href="http://www.cnblogs.com/chio/archive/2007/09/10/888260.html">虚析构函数(√)、纯虚析构函数(√)、虚构造函数(X)</a></p><p>为什么需要虚继承?虚继承实现原理解析，</p><pre><code>虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继 承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类,虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。虚继承的特点是，在任何派生类中的virtual基类总用同一个（共享）对象表示，</code></pre><p><a href="http://blog.csdn.net/hyg0811/article/details/11951855">C++虚拟继承</a></p><h3 id="设计模式：">设计模式：</h3><p>C++单例模式写法:</p><pre><code>静态化并不是单例 (Singleton) 模式:第一, 静态成员变量初始化顺序不依赖构造函数, 得看编译器心情的, 没法保证初始化顺序 (极端情况: 有 a b 两个成员对象, b 需要把 a 作为初始化参数传入, 你的类就 必须 得要有构造函数, 并确保初始化顺序).第二, 最严重的问题, 失去了面对对象的重要特性 -- &quot;多态&quot;, 静态成员方法不可能是 virtual 的. Log 类的子类没法享受 &quot;多态&quot; 带来的便利.class Log &#123;public:  static void Write(char const *logline);  static bool SaveTo(char const *filename);private:  static std::list&lt;std::string&gt; m_data;&#125;;In log.cpp we need to addstd::list&lt;std::string&gt; Log::m_data;饿汉模式:饿汉模式 是指单例实例在程序运行时被立即执行初始化:class Log &#123;public:  static Log* Instance() &#123;    return &amp;m_pInstance;  &#125;  virtual void Write(char const *logline);  virtual bool SaveTo(char const *filename);private:  Log();              // ctor is hidden  Log(Log const&amp;);    // copy ctor is hidden  static Log m_pInstance;  static std::list&lt;std::string&gt; m_data;&#125;;// in log.cpp we have to addLog Log::m_pInstance;这种模式的问题也很明显, 类现在是多态的, 但静态成员变量初始化顺序还是没保证.懒汉模式 (堆栈-粗糙版)单例实例只在第一次被使用时进行初始化:class Log &#123;public:  static Log* Instance() &#123;    if (!m_pInstance)      m_pInstance = new Log;    return m_pInstance;  &#125;  virtual void Write(char const *logline);  virtual bool SaveTo(char const *filename);private:  Log();        // ctor is hidden  Log(Log const&amp;);    // copy ctor is hidden  static Log* m_pInstance;  static std::list&lt;std::string&gt; m_data;&#125;;// in log.cpp we have to addLog* Log::m_pInstance = NULL;Instance() 只在第一次被调用时为 m_pInstance 分配内存并初始化. 嗯, 看上去所有的问题都解决了, 初始化顺序有保证, 多态也没问题.程序退出时, 析构函数没被执行. 这在某些设计不可靠的系统上会导致资源泄漏, 比如文件句柄, socket 连接, 内存等等对于这个问题, 比较土的解决方法是, 给每个 Singleton 类添加一个 destructor() 方法:懒汉模式 (局部静态变量-最佳版)它也被称为 Meyers Singleton [Meyers]:class Log &#123;public:  static Log&amp; Instance() &#123;    static Log theLog;    return theLog;  &#125;  virtual void Write(char const *logline);  virtual bool SaveTo(char const *filename);private:  Log();          // ctor is hidden  Log(Log const&amp;);      // copy ctor is hidden  Log&amp; operator=(Log const&amp;);  // assign op is hidden  static std::list&lt;std::string&gt; m_data;&#125;;在 Instance() 函数内定义局部静态变量的好处是, theLog `` 的构造函数只会在第一次调用 ``Instance() 时被初始化, 达到了和 &quot;堆栈版&quot; 相同的动态初始化效果, 保证了成员变量和 Singleton 本身的初始化顺序.它还有一个潜在的安全措施, Instance() 返回的是对局部静态变量的引用, 如果返回的是指针, Instance() 的调用者很可能会误认为他要检查指针的有效性, 并负责销毁. 构造函数和拷贝构造函数也私有化了, 这样类的使用者不能自行实例化.另外, 多个不同的 Singleton 实例的析构顺序与构造顺序相反.[C++ Singleton (单例) 模式最优实现](http://blog.yangyubo.com/2009/06/04/best-cpp-singleton-pattern/)</code></pre><p>用C++设计一个不能被继承的类。</p><pre><code>构造函数或析构函数为私有函数，所以该类是无法被继承的，</code></pre><p>如何定义一个只能在堆上定义对象的类?栈上呢</p><pre><code>只能在堆内存上实例化的类：将析构函数定义为private，在栈上不能自动调用析构函数，只能手动调用。也可以将构造函数定义为private，但这样需要手动写一个函数实现对象的构造。只能在栈内存上实例化的类：将函数operator new和operator delete定义为private，这样使用new操作符创建对象时候，无法调用operator new，delete销毁对象也无法调用operator delete。[设计一个只能在堆上或栈上实例化的类](http://www.cnblogs.com/luxiaoxun/archive/2012/08/03/2621827.html)</code></pre><p>满足上述3个条件</p><pre><code>[C++中的单例模式](http://www.cnblogs.com/xiehongfeng100/p/4781013.html)</code></pre><p>多重类构造和析构的顺序</p><pre><code>先调用基类的构造函数，在调用派生类的构造函数先构造的后析构，后构造的先析构</code></pre><h3 id="内存分配：">内存分配：</h3><p>内存分配方式有三种：</p><pre><code>（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。（3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</code></pre><p>c++运行时各类型内存分配（堆，栈，静态区，数据段，BSS，ELF），BSS段，<br>sizeof一个类求大小（字节对齐原则）、</p><p>C++四种强制类型转换，</p><p>int char float,long long long类型长度</p><h3 id="指针：">指针：</h3><p>防止指针的越界使用，</p><pre><code>必须让指针指向一个有效的内存地址, 1 防止数组越界 2 防止向一块内存中拷贝过多的内容 3 防止使用空指针 4 防止改变const修改的指针 5 防止改变指向静态存储区的内容 6 防止两次释放一个指针 7 防止使用野指针. </code></pre><p>什么是指针退化及防止、</p><pre><code>如果用一个数组作为函数入参 比如 void fun(char a[100]) &#123; cout&lt;&lt;SIZEOF(A)&lt;&#125;</code></pre><p>指针的移动问题，</p><pre><code>指针P ++具体移动的字节数等于指针指向的变量类型大小. </code></pre><p>Const,volatile修饰指针的含义，</p><p>堆和栈上的指针，</p><pre><code>指针所指向的这块内存是在哪里分配的,在堆上称为堆上的指针,在栈上为栈上的指针. 在堆上的指针,可以保存在全局数据结构中,供不同函数使用访问同一块内存. 在栈上的指针,在函数退出后,该内存即不可访问. </code></pre><p>指针的释放及内存泄露原因，</p><p>指针作为函数的参数，函数指针，</p><p>指针和引用及地址的区别，数组名，</p><pre><code>指针与地址的区别? 区别: 1指针意味着已经有一个指针变量存在,他的值是一个地址,指针变量本身也存放在一个长度为四个字节的地址当中,而地址概念本身并不代表有任何变量存在. 2 指针的值,如果没有限制,通常是可以变化的,也可以指向另外一个地址.    地址表示内存空间的一个位置点,他是用来赋给指针的,地址本身是没有大小概念,指针指向变量的大小,取决于地址后面存放的变量类型. 指针与数组名的关系? 其值都是一个地址,但前者是可以移动的,后者是不可变的. 指针和引用的区别（一般都会问到）相同点：1. 都是地址的概念；指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。区别：1. 指针是一个实体，而引用仅是个别名；2. 引用使用时无需解引用(*)，指针需要解引用；3. 引用只能在定义时被初始化一次，之后不可变；指针可变；4. 引用没有 const，指针有 const；5. 引用不能为空，指针可以为空；6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；7. 指针和引用的自增(++)运算意义不一样；8.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。</code></pre><p>迭代器与普通指针有什么区别</p><p>智能指针的原理,</p><pre><code>智能指针：实际指行为类似于指针的类对象 ，它的一种通用实现方法是采用引用计数的方法。1.智能指针将一个计数器与类指向的对象相关联，引用计数跟踪共有多少个类对象共享同一指针。2.每次创建类的新对象时，初始化指针并将引用计数置为1；3.当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；4.对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；这是因为左侧的指针指向了右侧指针所指向的对象，因此右指针所指向的对象的引用计数+1；5.调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。6.实现智能指针有两种经典策略：一是引入辅助类，二是使用句柄类。这里主要讲一下引入辅助类的方法</code></pre><p>其他：override和overload的区别，</p><pre><code>override（重写） 1、方法名、参数、返回值相同。2、子类方法不能缩小父类方法的访问权限。3、子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。4、存在于父类和子类之间。5、方法被定义为final不能被重写。overload（重载）1、参数类型、个数、顺序至少有一个不相同。  2、不能重载只有返回值不同的方法名。3、存在于父类和子类、同类中。Overload是重载的意思，Override是覆盖的意思，也就是重写。重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</code></pre><p>写string类的构造，析构，拷贝函数</p><pre><code>String 类的原型如下class String&#123;  public:         String(const char *str=NULL); //构造函数         String(const String &amp;other); //拷贝构造函数         ~String(void); //析构函数         String&amp; operator=(const String &amp;other); //等号操作符重载         ShowString();  private:         char *m_data; //指针&#125;;String::~String()&#123;   delete [] m_data; //析构函数，释放地址空间&#125;String::String(const char *str)&#123;   if (str==NULL)//当初始化串不存在的时候，为m_data申请一个空间存放'\0'；    &#123;       m_data=new char[1];       *m_data='\0';    &#125;   else//当初始化串存在的时候，为m_data申请同样大小的空间存放该串；    &#123;       int length=strlen(str);       m_data=new char[length+1];       strcpy(m_data,str);    &#125;&#125;String::String(const String &amp;other)//拷贝构造函数，功能与构造函数类似。&#123;   int length=strlen(other.m_data);   m_data=new [length+1];   strcpy(m_data,other.m_data);&#125;String&amp; String::operator =(const String &amp;other) &#123;   if (this==&amp;other)//当地址相同时，直接返回；       return *this;    delete [] m_data;//当地址不相同时，删除原来申请的空间，重新开始构造；   int length=sizeof(other.m_data);   m_data=new [length+1];   strcpy(m_data,other.m_data);   return *this; &#125;String::ShowString()//由于m_data是私有成员，对象只能通过public成员函数来访问；&#123;     cout&lt;&lt;this-&gt;m_data&lt;&lt;endl;&#125;main()&#123;String AD;char * p=&quot;ABCDE&quot;;String B(p);AD.ShowString();AD=B;AD.ShowString();&#125;</code></pre><p>1 指针的四要素</p><pre><code>1指针变量,表示一个内存地址,通常为逻辑地址,与实际的物理地址还有一个映射关系. 2指针变量的长度,在WIN32下为四个字节, 3指针指向的变量    该内存地址空间下存放的变量,具体内容可能是各种类型的变量. 4 指针指向的变量的长度,以该内存地址空间开始的内存空间大小. </code></pre><h2 id="数据结构算法：">数据结构算法：</h2><p>链表、树、哈希表、有效避免hash结果值的碰撞</p><p>排序算法性能比较</p><h2 id="操作系统：">操作系统：</h2><p>linux的内存管理机制，内存寻址方式，什么叫虚拟内存，内存调页算法，任务调度算法、</p><pre><code>Linux虚拟内存的实现需要6种机制的支持：地址映射机制、内存分配回收机制、缓存和刷新机制、请求页机制、交换机制和内存共享机制内存管理程序通过映射机制把用户程序的逻辑地址映射到物理地址。当用户程序运行时，如果发现程序中要用的虚地址没有对应的物理内存，就发出了请求页要求。如果有空闲的内存可供分配，就请求分配内存(于是用到了内存的分配和回收)，并把正在使用的物理页记录在缓存中(使用了缓存机制)。如果没有足够的内存可供分配，那么就调用交换机制；腾出一部分内存。另外，在地址映射中要通过TLB(翻译后援存储器)来寻找物理页；交换机制中也要用到交换缓存，并且把物理页内容交换到交换文件中，也要修改页表来映射文件地址。进程和线程、进程间及线程通信方式、共享内存的使用实现原理</code></pre><p>死锁必要条件及避免算法、</p><pre><code>1、资源不能共享，只能由一个进程使用。2、请求与保持（Hold andwait）：已经得到资源的进程可以再次申请新的资源。3、不可剥夺（Nopre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。4、循环等待：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源处理死锁的策略：1.忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。2.检测死锁并且恢复。3.仔细地对资源进行动态分配，以避免死锁。4.通过破除死锁四个必要条件之一，来防止死锁产生。）</code></pre><p>动态链接和静态链接的区别、</p><pre><code>动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在运行时再装入；而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了。</code></pre><p>c程序辨别系统是16位or32位,大端or小端字节序、</p><p>16or32</p><pre><code>法一：int k=~0;if((unsigned int)k &gt;63356) cout&lt;&lt;&quot;at least 32bits&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;16 bits&quot;&lt;&lt;endl;法二：//32为系统int i=65536;cout&lt;&lt;i&lt;&lt;endl;int j=65535;cout&lt;&lt;j&lt;&lt;endl;</code></pre><p>大or小</p><pre><code>1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。2) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：1)大端模式：低地址 -----------------&gt; 高地址0x12  |  0x34  |  0x56  |  0x782)小端模式：低地址 ------------------&gt; 高地址0x78  |  0x56  |  0x34  |  0x1232bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：内存地址小端模式存放内容大端模式存放内容0x40000x780x120x40010x560x340x40020x340x560x40030x120x784)大端小端没有谁优谁劣，各自优势便是对方劣势：小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。大端模式 ：符号位的判定固定为第一个字节，容易判断正负。BOOL IsBigEndian()  &#123;      int a = 0x1234;      char b =  *(char *)&amp;a;  //通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分      if( b == 0x12)      &#123;          return TRUE;      &#125;      return FALSE;  &#125;联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写：BOOL IsBigEndian()  &#123;      union NUM      &#123;          int a;          char b;      &#125;num;      num.a = 0x1234;      if( num.b == 0x12 )      &#123;          return TRUE;      &#125;      return FALSE;  &#125;一般操作系统都是小端，而通讯协议是大端的。常见CPU的字节序Big Endian : PowerPC、IBM、SunLittle Endian : x86、DECARM既可以工作在大端模式，也可以工作在小端模式。</code></pre><p>常见的信号、系统如何将一个信号通知到进程、</p><pre><code>信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号，也有人称作软中断。进程之间可以互相通过系统调用kill发送软中断信号。SIGHUP 1 A 终端挂起或者控制进程终止 SIGINT 2 A 键盘中断（如break键被按下） SIGQUIT 3 C 键盘的退出键被按下 SIGILL 4 C 非法指令 SIGABRT 6 C 由abort(3)发出的退出指令 SIGFPE 8 C 浮点异常 SIGKILL 9 AEF Kill信号 SIGSEGV 11 C 无效的内存引用 SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道 信号机制是异步的；当一个进程接收到一个信号时，它会立刻处理这个信号，而不会等待当前函数甚至当前一行代码结束运行。信号有几十种，分别代表着不同的意义。信号之间依靠它们的值来区分，但是通常在程序中使用信号的名字来表示一个信号。在Linux系统中，这些信号和以它们的名称命名的常量均定义在/usr/include/bits/signum.h文件中。（通常程序中不需要直接包含这个头文件，而应该包含&lt;signal.h&gt;。）信号事件的发生有两个来源：硬件来源(比如我们按下了键盘或者其它硬件故障)；软件来源，最常用发送信号的系统函数是kill, raise, alarm和setitimer以及sigqueue函数，软件来源还包括一些非法运算等操作。发送信号的主要函数有：kill()、raise()、 sigqueue()、alarm()、setitimer()以及abort()。进程可以通过三种方式来响应一个信号：（1）忽略信号，即对信号不做任何处理，其中，有两个信号不能忽略：SIGKILL及SIGSTOP；（2）捕捉信号。定义信号处理函数，当信号发生时，执行相应的处理函数；（3）执行缺省操作，</code></pre><p>linux系统的各类同步机制、linux系统的各类异步机制、</p><p>如何实现守护进程</p><pre><code>守护进程最重要的特性是后台运行。1. 在后台运行。为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。if(pid=fork())exit(0); //是父进程，结束父进程，子进程继续2. 脱离控制终端，登录会话和进程组有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长：setsid();说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。3. 禁止进程重新打开控制终端现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端：if(pid=fork()) exit(0); //结束第一子进程，第二子进程继续（第二子进程不再是会话组长）4. 关闭打开的文件描述符进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。按如下方法关闭它们：for(i=0;i 关闭打开的文件描述符close(i);&gt;5. 改变当前工作目录进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如 /tmpchdir(&quot;/&quot;)6. 重设文件创建掩模进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0);7. 处理SIGCHLD信号处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将 SIGCHLD信号的操作设为SIG_IGN。signal(SIGCHLD,SIG_IGN);这样，内核在子进程结束时不会产生僵尸进程。这一点与BSD4不同，BSD4下必须显式等待子进程结束才能释放僵尸进程。</code></pre><p>标准库函数和系统调用的区别，</p><pre><code>1、系统调用系统调用提供的函数如open, close, read, write, ioctl等，需包含头文件unistd.h。以write为例：其函数原型为 size_t write(int fd, const void *buf, size_t nbytes)，其操作对象为文件描述符或文件句柄fd(file descriptor)，要想写一个文件，必须先以可写权限用open系统调用打开一个文件，获得所打开文件的fd，例如fd=open(/&quot;/dev/video/&quot;, O_RDWR)。fd是一个整型值，每新打开一个文件，所获得的fd为当前最大fd加1。Linux系统默认分配了3个文件描述符值：0－standard input，1－standard output，2－standard error。系统调用通常用于底层文件访问（low-level file access），例如在驱动程序中对设备文件的直接访问。系统调用是操作系统相关的，因此一般没有跨操作系统的可移植性。系统调用发生在内核空间，因此如果在用户空间的一般应用程序中使用系统调用来进行文件操作，会有用户空间到内核空间切换的开销。事实上，即使在用户空间使用库函数来对文件进行操作，因为文件总是存在于存储介质上，因此不管是读写操作，都是对硬件（存储器）的操作，都必然会引起系统调用。也就是说，库函数对文件的操作实际上是通过系统调用来实现的。例如C库函数fwrite()就是通过write()系统调用来实现的。这样的话，使用库函数也有系统调用的开销，为什么不直接使用系统调用呢？这是因为，读写文件通常是大量的数据（这种大量是相对于底层驱动的系统调用所实现的数据操作单位而言），这时，使用库函数就可以大大减少系统调用的次数。这一结果又缘于缓冲区技术。在用户空间和内核空间，对文件操作都使用了缓冲区，例如用fwrite写文件，都是先将内容写到用户空间缓冲区，当用户空间缓冲区满或者写操作结束时，才将用户缓冲区的内容写到内核缓冲区，同样的道理，当内核缓冲区满或写结束时才将内核缓冲区内容写到文件对应的硬件媒介。2、库函数调用标准C库函数提供的文件操作函数如fopen, fread, fwrite, fclose,fflush, fseek等，需包含头文件stdio.h。以fwrite为例，其函数原型为size_t fwrite(const void *buffer,size_t size, size_t item_num, FILE *pf)，其操作对象为文件指针FILE *pf，要想写一个文件，必须先以可写权限用fopen函数打开一个文件，获得所打开文件的FILE结构指针pf，例如pf=fopen(/&quot;~/proj/filename/&quot;,/&quot;w/&quot;)。实际上，由于库函数对文件的操作最终是通过系统调用实现的，因此，每打开一个文件所获得的FILE结构指针都有一个内核空间的文件描述符fd与之对应。同样有相应的预定义的FILE指针：stdin－standard input，stdout－standard output，stderr－standard error。库函数调用通常用于应用程序中对一般文件的访问。库函数调用是系统无关的，因此可移植性好。由于库函数调用是基于C库的，因此也就不可能用于内核空间的驱动程序中对设备的操作</code></pre><p>fd和PCB，</p><p>32位系统一个进程最多有多少堆内存，</p><p>五种I/O 模式，</p><pre><code>五种I/O 模式：【1】       阻塞I/O           (Linux下的I/O操作默认是阻塞I/O，即open和socket创建的I/O都是阻塞I/O)【2】       非阻塞 I/O        (可以通过fcntl或者open时使用O_NONBLOCK参数，将fd设置为非阻塞的I/O)【3】       I/O 多路复用     (I/O多路复用，通常需要非阻塞I/O配合使用)【4】       信号驱动 I/O    (SIGIO)【5】        异步 I/O</code></pre><p>Apache 模型（Process Per Connection，简称PPC），TPC（ThreadPer Connection）模型，以及 select 模型和 poll 模型，epoll模型</p><pre><code>一般来说，程序进行输入操作有两步：1．等待有数据可以读2．将数据从系统内核中拷贝到程序的数据区。对于sock编程来说:         第一步:   一般来说是等待数据从网络上传到本地。当数据包到达的时候，数据将会从网络层拷贝到内核的缓存中；         第二步:   是从内核中把数据拷贝到程序的数据区中。 阻塞I/O模式                           //进程处于阻塞模式时，让出CPU，进入休眠状态        阻塞 I/O 模式是最普遍使用的 I/O 模式。是Linux系统下缺省的IO模式。       大部分程序使用的都是阻塞模式的 I/O 。       一个套接字建立后所处于的模式就是阻塞 I/O 模式。（因为Linux系统默认的IO模式是阻塞模式）对于一个UDP 套接字来说，数据就绪的标志比较简单：（1）已经收到了一整个数据报（2）没有收到。而 TCP 这个概念就比较复杂，需要附加一些其他的变量。       一个进程调用 recvfrom  ，然后系统调用并不返回知道有数据报到达本地系统，然后系统将数据拷贝到进程的缓存中。（如果系统调用收到一个中断信号，则它的调用会被中断）   我们称这个进程在调用recvfrom一直到从recvfrom返回这段时间是阻塞的。当recvfrom正常返回时，我们的进程继续它的操作 非阻塞模式I/O                          //非阻塞模式的使用并不普遍，因为非阻塞模式会浪费大量的CPU资源。       当我们将一个套接字设置为非阻塞模式，我们相当于告诉了系统内核： “当我请求的I/O 操作不能够马上完成，你想让我的进程进行休眠等待的时候，不要这么做，请马上返回一个错误给我。”      我们开始对 recvfrom 的三次调用，因为系统还没有接收到网络数据，所以内核马上返回一个EWOULDBLOCK的错误。      第四次我们调用 recvfrom 函数，一个数据报已经到达了，内核将它拷贝到我们的应用程序的缓冲区中，然后 recvfrom 正常返回，我们就可以对接收到的数据进行处理了。      当一个应用程序使用了非阻塞模式的套接字，它需要使用一个循环来不听的测试是否一个文件描述符有数据可读(称做 polling(轮询))。应用程序不停的 polling 内核来检查是否 I/O操作已经就绪。这将是一个极浪费 CPU资源的操作。这种模式使用中不是很普遍。  例如:         对管道的操作，最好使用非阻塞方式！ I/O多路复用                            //针对批量IP操作时，使用I/O多路复用，非常有好。       在使用 I/O 多路技术的时候，我们调用select()函数和 poll()函数或epoll函数(2.6内核开始支持)，在调用它们的时候阻塞，而不是我们来调用 recvfrom（或recv）的时候阻塞。       当我们调用 select函数阻塞的时候，select 函数等待数据报套接字进入读就绪状态。当select函数返回的时候，也就是套接字可以读取数据的时候。这时候我们就可以调用 recvfrom函数来将数据拷贝到我们的程序缓冲区中。        对于单个I/O操作，和阻塞模式相比较，select()和poll()或epoll并没有什么高级的地方。       而且，在阻塞模式下只需要调用一个函数：                            读取或发送函数。                  在使用了多路复用技术后，我们需要调用两个函数了：                             先调用 select()函数或poll()函数，然后才能进行真正的读写。       多路复用的高级之处在于::             它能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。 IO 多路技术一般在下面这些情况中被使用：1、当一个客户端需要同时处理多个文件描述符的输入输出操作的时候（一般来说是标准的输入输出和网络套接字)，I/O 多路复用技术将会有机会得到使用。2、当程序需要同时进行多个套接字的操作的时候。3、如果一个 TCP 服务器程序同时处理正在侦听网络连接的套接字和已经连接好的套接字。4、如果一个服务器程序同时使用 TCP 和 UDP 协议。5、如果一个服务器同时使用多种服务并且每种服务可能使用不同的协议（比如 inetd就是这样的）。异步IO模式有::      1、信号驱动I/O模式       2、异步I/O模式信号驱动I/O模式                                                  //自己没有用过。       我们可以使用信号，让内核在文件描述符就绪的时候使用 SIGIO 信号来通知我们。我们将这种模式称为信号驱动 I/O 模式。为了在一个套接字上使用信号驱动 I/O 操作，下面这三步是所必须的。（1）一个和 SIGIO信号的处理函数必须设定。（2）套接字的拥有者必须被设定。一般来说是使用 fcntl 函数的 F_SETOWN 参数来进行设定拥有者。（3）套接字必须被允许使用异步 I/O。一般是通过调用 fcntl 函数的 F_SETFL 命令，O_ASYNC为参数来实现。       虽然设定套接字为异步 I/O 非常简单，但是使用起来困难的部分是怎样在程序中断定产生 SIGIO信号发送给套接字属主的时候，程序处在什么状态。1．UDP 套接字的 SIGIO 信号                   (比较简单)在 UDP 协议上使用异步 I/O 非常简单．这个信号将会在这个时候产生：1、套接字收到了一个数据报的数据包。2、套接字发生了异步错误。        当我们在使用 UDP 套接字异步 I/O 的时候，我们使用 recvfrom()函数来读取数据报数据或是异步 I/O 错误信息。2．TCP 套接字的 SIGIO 信号                  (不会使用)          不幸的是，异步 I/O 几乎对 TCP 套接字而言没有什么作用。因为对于一个 TCP 套接字来说，SIGIO 信号发生的几率太高了，所以 SIGIO 信号并不能告诉我们究竟发生了什么事情。在 TCP 连接中， SIGIO 信号将会在这个时候产生：l  在一个监听某个端口的套接字上成功的建立了一个新连接。l  一个断线的请求被成功的初始化。l  一个断线的请求成功的结束。l  套接字的某一个通道（发送通道或是接收通道）被关闭。l  套接字接收到新数据。l  套接字将数据发送出去。l  发生了一个异步 I/O 的错误。一个对信号驱动 I/O 比较实用的方面是NTP（网络时间协议 Network TimeProtocol）服务器，它使用 UDP。这个服务器的主循环用来接收从客户端发送过来的数据报数据包，然后再发送请求。对于这个服务器来说，记录下收到每一个数据包的具体时间是很重要的。因为那将是返回给客户端的值，客户端要使用这个数据来计算数据报在网络上来回所花费的时间。图 6-8 表示了怎样建立这样的一个 UDP 服务器。  异步I/O模式             //比如写操作，只需用写，不一定写入磁盘(这就是异步I/O)的好处。异步IO的好处效率高。      当我们运行在异步 I/O 模式下时，我们如果想进行 I/O 操作，只需要告诉内核我们要进行 I/O 操作，然后内核会马上返回。具体的 I/O 和数据的拷贝全部由内核来完成，我们的程序可以继续向下执行。当内核完成所有的 I/O 操作和数据拷贝后，内核将通知我们的程序。异步 I/O 和  信号驱动I/O的区别是：        1、信号驱动 I/O 模式下，内核在操作可以被操作的时候通知给我们的应用程序发送SIGIO 消息。        2、异步 I/O 模式下，内核在所有的操作都已经被内核操作结束之后才会通知我们的应用程序。select，poll，epoll. Epoll 是何方神圣？Epoll 可是当前在 Linux 下开发大规模并发网络程序的热门人选， Epoll 在 Linux2.6 内核中正式引入，和 select 相似，其实都 I/O 多路复用技术而已，并没有什么神秘的。其实在Linux 下设计并发网络程序，向来不缺少方法，比如典型的 Apache 模型（ Process Per Connection ，简称PPC ）， TPC （ ThreadPer Connection ）模型，以及 select 模型和 poll 模型，那为何还要再引入 Epoll 这个东东呢？那还是有得说说的 …2. 常用模型的缺点如果不摆出来其他模型的缺点，怎么能对比出 Epoll 的优点呢。2.1 PPC/TPC 模型这两种模型思想类似，就是让每一个到来的连接一边自己做事去，别再来烦我。只是 PPC 是为它开了一个进程，而 TPC 开了一个线程。可是别烦我是有代价的，它要时间和空间啊，连接多了之后，那么多的进程 / 线程切换，这开销就上来了；因此这类模型能接受的最大连接数都不会高，一般在几百个左右。2.2 select 模型1. 最大并发数限制，因为一个进程所打开的 FD （文件描述符）是有限制的，www.linuxidc.com 由FD_SETSIZE 设置，默认值是 1024/2048 ，因此 Select 模型的最大并发数就被相应限制了。自己改改这个 FD_SETSIZE ？想法虽好，可是先看看下面吧 …2. 效率问题， select 每次调用都会线性扫描全部的 FD 集合，这样效率就会呈现线性下降，把 FD_SETSIZE 改大的后果就是，大家都慢慢来，什么？都超时了？？！！3. 内核 / 用户空间内存拷贝问题，如何让内核把 FD 消息通知给用户空间呢？在这个问题上 select 采取了内存拷贝方法。2.3 poll 模型基本上效率和select 是相同的，select 缺点的 2 和 3 它都没有改掉。3. Epoll 的提升把其他模型逐个批判了一下，再来看看 Epoll 的改进之处吧，其实把 select 的缺点反过来那就是 Epoll 的优点了。3.1. Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, 一般来说这个数目和系统内存关系很大，具体数目可以 cat /proc/sys/fs/file-max 察看。3.2. 效率提升， Epoll 最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中， Epoll 的效率就会远远高于 select 和 poll 。3.3. 内存拷贝， Epoll 在这点上使用了“共享内存 ”，这个内存拷贝也省略了。4. Epoll 为什么高效Epoll 的高效和其数据结构的设计是密不可分的，这个下面就会提到。首先回忆一下select 模型，当有I/O 事件到来时，select 通知应用程序有事件到了快去处理，而应用程序必须轮询所有的 FD 集合，测试每个 FD 是否有事件发生，并处理事件；代码像下面这样：int res = select(maxfd+1, &amp;readfds,NULL, NULL, 120);if (res &gt; 0)&#123;    for (int i = 0; i &lt;MAX_CONNECTION; i++)    &#123;       if (FD_ISSET(allConnection[i], &amp;readfds))       &#123;           handleEvent(allConnection[i]);       &#125;    &#125;&#125;// if(res == 0) handle timeout, res &lt; 0handle errorEpoll 不仅会告诉应用程序有I/0事件到来，还会告诉应用程序相关的信息，这些信息是应用程序填充的，因此根据这些信息应用程序就能直接定位到事件，而不必遍历整个FD 集合。int res = epoll_wait(epfd, events, 20,120);for (int i = 0; i &lt; res;i++)&#123;    handleEvent(events[n]);&#125;5. Epoll 关键数据结构前面提到Epoll 速度快和其数据结构密不可分，其关键数据结构就是：struct epoll_event &#123;    __uint32_tevents;      // Epoll events    epoll_data_tdata;      // User data variable&#125;;typedef union epoll_data &#123;    void *ptr;    int fd;    __uint32_t u32;    __uint64_t u64;&#125; epoll_data_t;可见epoll_data 是一个 union 结构体 , 借助于它应用程序可以保存很多类型的信息 :fd 、指针等等。有了它，应用程序就可以直接定位目标了。</code></pre><p>socket服务端的实现，select和epoll的区别(必问)</p><pre><code>select的本质是采用32个整数的32位，即32*32= 1024来标识，fd值为1-1024。当fd的值超过1024限制时，就必须修改FD_SETSIZE的大小。这个时候就可以标识32*max值范围的fd。对于单进程多线程，每个线程处理多个fd的情况，select是不适合的。1.所有的线程均是从1-32*max进行扫描，每个线程处理的均是一段fd值，这样做有点浪费2.1024上限问题，一个处理多个用户的进程，fd值远远大于1024所以这个时候应该采用poll，poll传递的是数组头指针和该数组的长度，只要数组的长度不是很长，性能还是很不错的，因为poll一次在内核中申请4K（一个页的大小来存放fd），尽量控制在4K以内epoll还是poll的一种优化，返回后不需要对所有的fd进行遍历，在内核中维持了fd的列表。select和poll是将这个内核列表维持在用户态，然后传递到内核中。但是只有在2.6的内核才支持。epoll更适合于处理大量的fd ，且活跃fd不是很多的情况，毕竟fd较多还是一个串行的操作 epoll哪些触发模式，有啥区别？（必须非常详尽的解释水平触发和边缘触发的区别，以及边缘触发在编程中要做哪些更多的确认）epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</code></pre><p>惊群现象，</p><pre><code> 举一个很简单的例子，当你往一群鸽子中间扔一块食物，虽然最终只有一个鸽子抢到食物，但所有鸽子都会被惊动来争夺，没有抢到食物的鸽子只好回去继续睡觉，等待下一块食物到来。这样，每扔一块食物，都会惊动所有的鸽子，即为惊群。对于操作系统来说，多个进程/线程在等待同一资源是，也会产生类似的效果，其结果就是每当资源可用，所有的进程/线程都来竞争资源，造成的后果：1）系统对用户进程/线程频繁的做无效的调度、上下文切换，系统系能大打折扣。2）为了确保只有一个线程得到资源，用户必须对资源操作进行加锁保护，进一步加大了系统开销。什么是惊群    最常见的例子就是对于socket描述符的accept操作，当多个用户进程/线程监听在同一个端口上时，由于实际只可能accept一次，因此就会产生惊群现象，当然前面已经说过了，这个问题是一个古老的问题，新的操作系统内核已经解决了这一问题。        linux内核解决惊群问题的方法    对于一些已知的惊群问题，内核开发者增加了一个“互斥等待”选项。一个互斥等待的行为与睡眠基本类似，主要的不同点在于：    1）当一个等待队列入口有 WQ_FLAG_EXCLUSEVE 标志置位, 它被添加到等待队列的尾部. 没有这个标志的入口项, 相反, 添加到开始.    2）当 wake_up 被在一个等待队列上调用时, 它在唤醒第一个有 WQ_FLAG_EXCLUSIVE 标志的进程后停止。    也就是说，对于互斥等待的行为，比如如对一个listen后的socket描述符，多线程阻塞accept时，系统内核只会唤醒所有正在等待此时间的队列的第一个，队列中的其他人则继续等待下一次事件的发生，这样就避免的多个线程同时监听同一个socket描述符时的惊群问题。</code></pre><p>块设备和字符设备有什么区别，</p><pre><code>(1) 字符设备：提供连续的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持按字节/字符来读写数据。举例来说，调制解调器是典型的字符设备。(2) 块设备：应用程序可以随机访问设备数据，程序可自行确定读取数据的位置。硬盘是典型的块设备，应用程序可以寻址磁盘上的任何位置，并由此读取数据。此外，数据的读写只能以块(通常是512B)的倍数进行。与字符设备不同，块设备并不支持基于字符的寻址。两种设备本身并没用严格的区分，主要是字符设备和块设备驱动程序提供的访问接口（file I/O API）是不一样的。本文主要就数据接口、访问接口和设备注册方法对两种设备进行比较。</code></pre><p>用户态和内核态的区别</p><pre><code>虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，</code></pre><p>linux文件系统：inode，inode存储了哪些东西，目录名，文件名存在哪里</p><pre><code>inode包含文件的元信息，具体来说有以下内容：　　* 文件的字节数　　* 文件拥有者的User ID　　* 文件的Group ID　　* 文件的读、写、执行权限　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。　　* 链接数，即有多少文件名指向这个inode　　* 文件数据block的位置　　　inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。每个inode都有一个号码，操作系统用inode号码来识别不同的文件。这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。一般情况下，文件名和inode号码是&quot;一一对应&quot;关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为&quot;硬链接&quot;（hard link）。ln命令可以创建硬链接：ln 源文件 目标文件文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的&quot;软链接&quot;（soft link）或者&quot;符号链接（symbolic link）。这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：&quot;No such file or directory&quot;。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode&quot;链接数&quot;不会因此发生变化。ln -s命令可以创建软链接。：ln -s 源文文件或目录 目标文件或目录http://www.ruanyifeng.com/blog/2011/12/inode.html</code></pre><p>/proc存在哪里（存在内存上）</p><pre><code>/proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 /proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的http://www.ibm.com/developerworks/cn/linux/l-proc.html</code></pre><h2 id="网络：">网络：</h2><p>TCP和UDP区别、</p><pre><code>key:TCP是一种面向连接的、可靠的、字节流服务1.面向链接：TCP面向链接，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须通过三次握手先建立一个TCP连接。在一个TCP中仅有两方彼此通信，多播和广播不能用于TCP。UDP是不可靠的传输，传输前不需要建立链接，可以应用多播和广播实现一对多的通信。 2.可靠性：TCP提供端到端的流量控制，对收到的数据进行确认，采用超时重发，对失序的数据进行重新排序等机制保证数据通信的可靠性。而UDP是一种不可靠的服务，接收方可能不能收到发送方的数据报。 3.TCP是一种流模式的协议，UDP是一种数据报模式的协议。进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。TCP应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。TCP会有粘包和半包的现象。 4.效率上：速度上，一般TCP速度慢，传输过程中需要对数据进行确认，超时重发，还要对数据进行排序。UDP没有这些机制所以速度快。数据比例，TCP头至少20个字节，UDP头8个字节，相对效率高。组装效率上：TCP头至少20个字节，UDP头8个字节，系统组装上TCP相对慢。 5.用途上：用于TCP可靠性，http，ftp使用。而由于UDP速度快，视频，在线游戏多用UDP，保证实时性 对于第三点的理解。TCP可能发送100个“包”，而接收到50个“包”，不是丢“包”了，而是每次接受的“包”都比发送的多，其实TCP并没有包的概念。例如，每次发10个字节，可能读得时候一次读了20个字节。TCP是一种流模式的协议，在接收到的缓存中按照发送的包得顺序自动按照顺序拼接好，因为数据基本来自同一个主机，而且是按照顺序发送过来的，TCP的缓存中存放的就是，连续的数据。感觉好像是多封装了一步比UDP。而UDP因为可能两个不同的主机，给同一个主机发送，（一个端口可能收到多个应用程序的数据），或者按照TCP那样合并数据，必然会造成数据错误。我觉得关键的原因还是，TCP是面向连接，而UDP是无连接的，这就导致，TCP接收的数据为一个主机发来且有序无误的，而UDP可能是多个主机发来的无序，可能错误的。</code></pre><p>TCP和UDP头部字节定义，</p><p>TCP和UDP三次握手和四次挥手状态及消息类型,</p><p>time_wait，close_wait状态产生原因，keepalive，</p><pre><code>TIME_WAIT：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。如果使用了nginx代理，那么系统TIME_WAIT的数量会变得比较多，这是由于nginx代理使用了短链接的方式和后端交互的原因，使得nginx和后端的ESTABLISHED变得很少而TIME_WAIT很多。这不但发生在安装nginx的代理服务器上，而且也会使后端的app服务器上有大量的TIME_WAIT。查阅TIME_WAIT资料，发现这个状态很多也没什么大问题，但可能因为它占用了系统过多的端口，导致后续的请求无法获取端口而造成障碍。虽然TIME_WAIT会造成一些问题，但是要完全枪毙掉它也是不正当的，虽然看起来这么做没什么错。具体可看这篇文档：http://hi.baidu.com/tim_bi/blog/item/35b005d784ca91d5a044df1d.html所以目前看来最好的办法是让每个TIME_WAIT早点过期。在linux上可以这么配置：#让TIME_WAIT状态可以重用，这样即使TIME_WAIT占满了所有端口，也不会拒绝新的请求造成障碍echo &quot;1&quot; &gt; /proc/sys/net/ipv4/tcp_tw_reuse#让TIME_WAIT尽快回收，我也不知是多久，观察大概是一秒钟echo &quot;1&quot; &gt; /proc/sys/net/ipv4/tcp_tw_recycle很多文档都会建议两个参数都配置上，但是我发现只用修改tcp_tw_recycle就可以解决问题的了，TIME_WAIT重用TCP协议本身就是不建议打开的。不能重用端口可能会造成系统的某些服务无法启动，比如要重启一个系统监控的软件，它用了40000端口，而这个端口在软件重启过程中刚好被使用了，就可能会重启失败的。linux默认考虑到了这个问题，有这么个设定：#查看系统本地可用端口极限值cat /proc/sys/net/ipv4/ip_local_port_range用这条命令会返回两个数字，默认是：32768 61000，说明这台机器本地能向外连接61000-32768=28232个连接，注意是本地向外连接，不是这台机器的所有连接，不会影响这台机器的80端口的对外连接数。但这个数字会影响到代理服务器（nginx）对app服务器的最大连接数，因为nginx对app是用的异步传输，所以这个环节的连接速度很快，所以堆积的连接就很少。假如nginx对app服务器之间的带宽出了问题或是app服务器有问题，那么可能使连接堆积起来，这时可以通过设定nginx的代理超时时间，来使连接尽快释放掉，一般来说极少能用到28232个连接。因为有软件使用了40000端口监听，常常出错的话，可以通过设定ip_local_port_range的最小值来解决：echo &quot;40001 61000&quot; &gt; /proc/sys/net/ipv4/ip_local_port_range但是这么做很显然把系统可用端口数减少了，这时可以把ip_local_port_range的最大值往上调，但是好习惯是使用不超过32768的端口来侦听服务，另外也不必要去修改ip_local_port_range数值成1024 65535之类的，意义不大。因为使用了nginx代理，在windows下也会造成大量TIME_WAIT，当然windows也可以调整：在注册表（regedit）的HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters上添加一个DWORD类型的值TcpTimedWaitDelay，值就是秒数，即可。windows默认是重用TIME_WAIT，我现在还不知道怎么改成不重用的，本地端口也没查到是什么值，但这些都关系不大，都可以按系统默认运作。------------------------------------------------------------------------------------------------------------------------TIME_WAIT状态根据TCP协议，主动发起关闭的一方，会进入TIME_WAIT状态，持续2*MSL(Max Segment Lifetime)，缺省为240秒，在这个post中简洁的介绍了为什么需要这个状态。值得一说的是，对于基于TCP的HTTP协议，关闭TCP连接的是Server端，这样，Server端会进入TIME_WAIT状态，可想而知，对于访问量大的Web Server，会存在大量的TIME_WAIT状态，假如server一秒钟接收1000个请求，那么就会积压240*1000=240，000个TIME_WAIT的记录，维护这些状态给Server带来负担。当然现代操作系统都会用快速的查找算法来管理这些TIME_WAIT，所以对于新的TCP连接请求，判断是否hit中一个TIME_WAIT不会太费时间，但是有这么多状态要维护总是不好。HTTP协议1.1版规定default行为是Keep-Alive，也就是会重用TCP连接传输多个request/response，一个主要原因就是发现了这个问题。还有一个方法减缓TIME_WAIT压力就是把系统的2*MSL时间减少，因为240秒的时间实在是忒长了点，对于Windows，修改注册表，在HKEY_LOCAL_MACHINE\ SYSTEM\CurrentControlSet\Services\ Tcpip\Parameters上添加一个DWORD类型的值TcpTimedWaitDelay，一般认为不要少于60，不然可能会有麻烦。对于大型的服务，一台server搞不定，需要一个LB(Load Balancer)把流量分配到若干后端服务器上，如果这个LB是以NAT方式工作的话，可能会带来问题。假如所有从LB到后端Server的IP包的source address都是一样的(LB的对内地址），那么LB到后端Server的TCP连接会受限制，因为频繁的TCP连接建立和关闭，会在server上留下TIME_WAIT状态，而且这些状态对应的remote address都是LB的，LB的source port撑死也就60000多个(2^16=65536,1~1023是保留端口，还有一些其他端口缺省也不会用），每个LB上的端口一旦进入Server的TIME_WAIT黑名单，就有240秒不能再用来建立和Server的连接，这样LB和Server最多也就能支持300个左右的连接。如果没有LB，不会有这个问题，因为这样server看到的remote address是internet上广阔无垠的集合，对每个address，60000多个port实在是够用了。一开始我觉得用上LB会很大程度上限制TCP的连接数，但是实验表明没这回事，LB后面的一台Windows Server 2003每秒处理请求数照样达到了600个，难道TIME_WAIT状态没起作用？用Net Monitor和netstat观察后发现，Server和LB的XXXX端口之间的连接进入TIME_WAIT状态后，再来一个LB的XXXX端口的SYN包，Server照样接收处理了，而是想像的那样被drop掉了。翻书，从书堆里面找出覆满尘土的大学时代买的《UNIX Network Programming, Volume 1, Second Edition: Networking APIs: Sockets and XTI》，中间提到一句，对于BSD-derived实现，只要SYN的sequence number比上一次关闭时的最大sequence number还要大，那么TIME_WAIT状态一样接受这个SYN，难不成Windows也算BSD-derived?有了这点线索和关键字(BSD)，找到这个post，在NT4.0的时候，还是和BSD-derived不一样的，不过Windows Server 2003已经是NT5.2了，也许有点差别了。做个试验，用Socket API编一个Client端，每次都Bind到本地一个端口比如2345，重复的建立TCP连接往一个Server发送Keep-Alive=false的HTTP请求，Windows的实现让sequence number不断的增长，所以虽然Server对于Client的2345端口连接保持TIME_WAIT状态，但是总是能够接受新的请求，不会拒绝。那如果SYN的Sequence Number变小会怎么样呢？同样用Socket API，不过这次用Raw IP，发送一个小sequence number的SYN包过去，Net Monitor里面看到，这个SYN被Server接收后如泥牛如海，一点反应没有，被drop掉了。按照书上的说法，BSD-derived和Windows Server 2003的做法有安全隐患，不过至少这样至少不会出现TIME_WAIT阻止TCP请求的问题，当然，客户端要配合，保证不同TCP连接的sequence number要上涨不要下降。----------------------------------------------------------------------------------------------------------------------------Socket中的TIME_WAIT状态在高并发短连接的server端，当server处理完client的请求后立刻closesocket此时会出现time_wait状态然后如果client再并发2000个连接，此时部分连接就连接不上了,用linger强制关闭可以解决此问题，但是linger会导致数据丢失，linger值为0时是强制关闭,无论并发多少多能正常连接上,如果非0会发生部分连接不上的情况!（可调用setsockopt设置套接字的linger延时标志，同时将延时时间设置为0。）TCP/IP的RFC文档。TIME_WAIT是TCP连接断开时必定会出现的状态。是无法避免掉的，这是TCP协议实现的一部分。在WINDOWS下，可以修改注册表让这个时间变短一些time_wait的时间为2msl,默认为4min.你可以通过改变这个变量:TcpTimedWaitDelay 把它缩短到30sTCP要保证在所有可能的情况下使得所有的数据都能够被投递。当你关闭一个socket时，主动关闭一端的socket将进入TIME_WAIT状态，而被动关闭一方则转入CLOSED状态，这的确能够保证所有的数据都被传输。当一个socket关闭的时候，是通过两端互发信息的四次握手过程完成的，当一端调用close()时，就说明本端没有数据再要发送了。这好似看来在握手完成以后，socket就都应该处于关闭CLOSED状态了。但这有两个问题，首先，我们没有任何机制保证最后的一个ACK能够正常传输，第二，网络上仍然有可能有残余的数据包(wandering duplicates)，我们也必须能够正常处理。通过正确的状态机，我们知道双方的关闭过程如下图假设最后一个ACK丢失了，服务器会重发它发送的最后一个FIN，所以客户端必须维持一个状态信息，以便能够重发ACK；如果不维持这种状态，客户端在接收到FIN后将会响应一个RST，服务器端接收到RST后会认为这是一个错误。如果TCP协议能够正常完成必要的操作而终止双方的数据流传输，就必须完全正确的传输四次握手的四个节，不能有任何的丢失。这就是为什么socket在关闭后，仍然处于 TIME_WAIT状态，因为他要等待以便重发ACK。如果目前连接的通信双方都已经调用了close()，假定双方都到达CLOSED状态，而没有TIME_WAIT状态时，就会出现如下的情况。现在有一个新的连接被建立起来，使用的IP地址与端口与先前的完全相同，后建立的连接又称作是原先连接的一个化身。还假定原先的连接中有数据报残存于网络之中，这样新的连接收到的数据报中有可能是先前连接的数据报。为了防止这一点，TCP不允许从处于TIME_WAIT状态的socket建立一个连接。处于TIME_WAIT状态的socket在等待两倍的MSL时间以后（之所以是两倍的MSL，是由于MSL是一个数据报在网络中单向发出到认定丢失的时间，一个数据报有可能在发送图中或是其响应过程中成为残余数据报，确认一个数据报及其响应的丢弃的需要两倍的MSL），将会转变为CLOSED状态。这就意味着，一个成功建立的连接，必然使得先前网络中残余的数据报都丢失了。由于TIME_WAIT状态所带来的相关问题，我们可以通过设置SO_LINGER标志来避免socket进入TIME_WAIT状态，这可以通过发送RST而取代正常的TCP四次握手的终止方式。但这并不是一个很好的主意，TIME_WAIT对于我们来说往往是有利的。客户端与服务器端建立TCP/IP连接后关闭SOCKET后，服务器端连接的端口状态为TIME_WAIT是不是所有执行主动关闭的socket都会进入TIME_WAIT状态呢？有没有什么情况使主动关闭的socket直接进入CLOSED状态呢？主动关闭的一方在发送最后一个 ack 后就会进入 TIME_WAIT 状态 停留2MSL（max segment lifetime）时间这个是TCP/IP必不可少的，也就是“解决”不了的。也就是TCP/IP设计者本来是这么设计的主要有两个原因1。防止上一次连接中的包，迷路后重新出现，影响新连接   （经过2MSL，上一次连接中所有的重复包都会消失）2。可靠的关闭TCP连接   在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发   fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以   主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。TIME_WAIT 并不会占用很大资源的，除非受到攻击。还有，如果一方 send 或 recv 超时，就会直接进入 CLOSED 状态socket-faq中的这一段讲的也很好，摘录如下：2.7. Please explain the TIME_WAIT state.</code></pre><p>什么是滑动窗口，超时重传，</p><p>列举你所知道的tcp选项，</p><p>connect会阻塞检测及防止，socket什么情况下可读？</p><p>connect会阻塞，怎么解决?(必考必问)</p><pre><code>最通常的方法最有效的是加定时器；也可以采用非阻塞模式。设置非阻塞，返回之后用select检测状态)</code></pre><p>如果select返回可读，结果只读到0字节，什么情况？</p><pre><code>某个套接字集合中没有准备好，可能会select内存用FD_CLR清该位为0；</code></pre><p>socket什么情况下可读？</p><pre><code>每次读操作返回前都要检查是否还有剩余数据没读完，如果是的话保持数据有效标志，不这样设计的话会出现明显的不一致，那就是数据在读缓冲但没有读有效标志。</code></pre><p>keepalive是什么东东？如何使用？</p><pre><code>设置Keepalive参数，检测已中断的客户连接在TCP中有一个Keep-alive的机制可以检测死连接，原理很简单，TCP会在空闲了一定时间后发送数据给对方：1.如果主机可达，对方就会响应ACK应答，就认为是存活的。2.如果可达，但应用程序退出，对方就发RST应答，发送TCP撤消连接。3.如果可达，但应用程序崩溃，对方就发FIN消息。4.如果对方主机不响应ack, rst，继续发送直到超时，就撤消连接。这个时间就是默认的二个小时。</code></pre><p>UDP中使用connect的好处:</p><pre><code>1:会提升效率.前面已经描述了.2:高并发服务中会增加系统稳定性.原因:假设client A 通过非connect的UDP与serverB,C通信.B,C提供相同服务.为了负载均衡,我们让A与B,C交替通信.A 与 B通信IPa:PORTa&lt;----&gt; IPb:PORTbA 与 C通信IPa:PORTa'&lt;----&gt;IPc:PORTc 假设PORTa 与 PORTa'相同了(在大并发情况下会发生这种情况),那么就有可能出现A等待B的报文,却收到了C的报文.导致收报错误.解决方法内就是采用connect的UDP通信方式.在A中创建两个udp,然后分别connect到B,C.</code></pre><p>长连接和短连接,</p><p>DNS和HTTP协议，HTTP请求方式，</p><p>cookie,session,localstroage,</p><p>一致性哈希负载均衡，</p><p>描述在浏览器中敲入一个网址并按下回车后所发生的事情，</p><p>PING命令</p><pre><code>ping命令所利用的原理是这样的:网络上的机器都有唯一确定的IP地址，我们给目标IP地址发送一个数据包，对方就要返回一个同样大小的数据包，根据返回的数据包我们可以确定目标主机的存在，可以初步判断目标主机的操作系统等。</code></pre><h2 id="数据库：">数据库：</h2><p>谈谈你对数据库中索引的理解，索引和主键区别</p><ul><li><p>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。</p></li><li><p>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。</p><pre><code>  聚集索引：该索引中键值的逻辑顺序决定了表中相应行的物理顺序。  聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。       聚集索引使用注意事项   定义聚集索引键时使用的列越少越好。   • 包含大量非重复值的列。  .• 使用下列运算符返回一个范围值的查询：BETWEEN、&gt;、&gt;=、&lt; 和 &lt;=。   •  被连续访问的列。   •  回大型结果集的查询。   • 经常被使用联接或 GROUP BY 子句的查询访问的列；一般来说，这些是外键列。对 ORDER BY 或 GROUP BY 子句中指定的列进行索引，可以使 SQL Server 不必对数据进行排序，因为这些行已经排序。这样可以提高查询性能。  •  OLTP 类型的应用程序，这些程序要求进行非常快速的单行查找（一般通过主键）。应在主键上创建聚集索引。  聚集索引不适用于：   • 频繁更改的列 。这将导致整行移动（因为 SQL Server 必须按物理顺序保留行中的数据值）。这一点要特别注意，因为在大数据量事务处理系统中数据是易失的。   • 宽键 。来自聚集索引的键值由所有非聚集索引作为查找键使用，因此存储在每个非聚集索引的叶条目内。      非聚集索引：数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。    非聚集索引中的项目按索引键值的顺序存储，而表中的信息按另一种顺序存储（这可以由聚集索引规定）。对于非聚集索引，可以为在表非聚集索引中查找数据时常用的每个列创建一个非聚集索引。有些书籍包含多个索引。例如，一本介绍园艺的书可能会包含一个植物通俗名称索引，和一个植物学名索引，因为这是读者查找信息的两种最常用的方法。        一个通俗的举例，说明两者的区别    其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。  　   如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。  第一：聚集索引的约束是唯一性，是否要求字段也是唯一的呢？  分析：如果认为是的朋友，可能是受系统默认设置的影响，一般我们指定一个表的主键，如果这个表之前没有聚集索引，同时建立主键时候没有强制指定使用非聚集索引,SQL会默认在此字段上创建一个聚集索引，而主键都是唯一的，所以理所当然的认为创建聚集索引的字段也需要唯一。  结论：聚集索引可以创建在任何一列你想创建的字段上，这是从理论上讲，实际情况并不能随便指定，否则在性能上会是恶梦。  第二：为什么聚集索引可以创建在任何一列上，如果此表没有主键约束，即有可能存在重复行数据呢？  粗一看，这还真是和聚集索引的约束相背，但实际情况真可以创建聚集索引。  分析其原因是：如果未使用 UNIQUE 属性创建聚集索引，数据库引擎将向表自动添加一个四字节 uniqueifier 列。必要时，数据库引擎 将向行自动添加一个 uniqueifier 值，使每个键唯一。此列和列值供内部使用，用户不能查看或访问。  第三：是不是聚集索引就一定要比非聚集索引性能优呢？  如果想查询学分在60-90之间的学生的学分以及姓名，在学分上创建聚集索引是否是最优的呢？  答：否。既然只输出两列，我们可以在学分以及学生姓名上创建联合非聚集索引，此时的索引就形成了覆盖索引，即索引所存储的内容就是最终输出的数据，这种索引在比以学分为聚集索引做查询性能更好。  第四：在数据库中通过什么描述聚集索引与非聚集索引的？  索引是通过二叉树的形式进行描述的，我们可以这样区分聚集与非聚集索引的区别：聚集索引的叶节点就是最终的数据节点，而非聚集索引的叶节仍然是索引节点，但它有一个指向最终数据的指针。  第五：在主键是创建聚集索引的表在数据插入上为什么比主键上创建非聚集索引表速度要慢？  有了上面第四点的认识，我们分析这个问题就有把握了，在有主键的表中插入数据行，由于有主键唯一性的约束，所以需要保证插入的数据没有重复。我们来比较下主键为聚集索引和非聚集索引的查找情况:聚集索引由于索引叶节点就是数据页，所以如果想检查主键的唯一性，需要遍历所有数据节点才行，但非聚集索引不同，由于非聚集索引上已经包含了主键值，所以查找主键唯一性，只需要遍历所有的索引页就行，这比遍历所有数据行减少了不少IO消耗。这就是为什么主键上创建非聚集索引比主键上创建聚集索引在插入数据时要快的真正原因。</code></pre></li></ul><p>现在普通关系数据库用得数据结构是什么类型的数据结构，</p><pre><code>B+树[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)</code></pre><p>索引的优点和缺点，</p><pre><code>建立索引的优点1.大大加快数据的检索速度;2.创建唯一性索引，保证数据库表中每一行数据的唯一性;3.加速表和表之间的连接;4.在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。 索引的缺点1.索引需要占物理空间。2.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。唯一索引唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在 employee 表中职员的姓 (lname) 上创建了唯一索引，则任何两个员工都不能同姓。 主键索引数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。 </code></pre><p>关系型数据库和非关系数据库的特点，</p><pre><code>简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。非关系型数据库提出另一种理念，例如，以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这 样就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，用户可以根据需要去添加自己需要的字段，这样，为了获取用户的不同信息，不需要 像关系型数据库中，要对多表进行关联查询。仅需要根据id取出相应的value就可以完成查询。但非关系型数据库由于很少的约束，他也不能够提供像SQL 所提供的where这种对于字段属性值情况的查询。并且难以体现设计的完整性。他只适合存储一些较为简单的数据，对于需要进行较复杂查询的数据，SQL数 据库显的更为合适。关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点，这个特性使得关系型数据库可以用于几乎所有对一致性有要求的系统中，如典型的银行系统。但是，在网页应用中，尤其是SNS应用中，一致性却不是显得那么重要，用户A看到的内容和用户B看到同一用户C内容更新不一致是可以容忍的，或者 说，两个人看到同一好友的数据更新的时间差那么几秒是可以容忍的，因此，关系型数据库的最大特点在这里已经无用武之地，起码不是那么重要了。相反地，关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差，而像微博、facebook这类SNS的应用，对并发读写能力要求极 高，关系型数据库已经无法应付(在读方面，传统上为了克服关系型数据库缺陷，提高性能，都是增加一级memcache来静态化网页，而在SNS中，变化太 快，memchache已经无能为力了)，因此，必须用新的一种数据结构存储来代替关系数据库。关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性极差，而在SNS中，系统的升级，功能的增加，往往意味着数据结构巨大变动，这一点关系型数据库也难以应付，需要新的结构化数据存储。于是，非关系型数据库应运而生，由于不可能用一种数据结构化存储应付所有的新的需求，因此，非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。必须强调的是，数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库这员老将。非关系型数据库分类：主要分为以下几类：面向高性能并发读写的key-value数据库：key-value数据库的主要特点即使具有极高的并发读写性能，Redis,Tokyo Cabinet,Flare就是这类的代表面向海量数据访问的面向文档数据库：这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为MongoDB以及CouchDB面向可扩展性的分布式数据库：这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化</code></pre><p><a href="http://my.oschina.net/u/1773689/blog/364548">关系型数据库和非关系型数据库</a></p><p>乐观锁与悲观锁的区别，</p><pre><code>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。[1]      悲观锁假定其他用户企图访问或者改变你正在访问、更改的对象的概率是很高的，因此在悲观锁的环境中，在你开始改变此对象之前就将该对象锁住，并且直到你提交了所作的更改之后才释放锁。悲观的缺陷是不论是页锁还是行锁，加锁的时间可能会很长，这样可能会长时间的限制其他用户的访问，也就是说悲观锁的并发访问性不好。乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。[1] 乐观锁不能解决脏读的问题。    乐观锁则认为其他用户企图改变你正在更改的对象的概率是很小的，因此乐观锁直到你准备提交所作的更改时才将对象锁住，当你读取以及改变该对象时并不加锁。可见乐观锁加锁的时间要比悲观锁短，乐观锁可以用较大的锁粒度获得较好的并发访问性能。但是如果第二个用户恰好在第一个用户提交更改之前读取了该对象，那么当他完成了自己的更改进行提交时，数据库就会发现该对象已经变化了，这样，第二个用户不得不重新读取该对象并作出更改。这说明在乐观锁环境中，会增加并发用户读取对象的次数。从数据库厂商的角度看，使用乐观的页锁是比较好的，尤其在影响很多行的批量操作中可以放比较少的锁，从而降低对资源的需求提高数据库的性能。再考虑聚集索引。在数据库中记录是按照聚集索引的物理顺序存放的。如果使用页锁，当两个用户同时访问更改位于同一数据页上的相邻两行时，其中一个用户必须等待另一个用户释放锁，这会明显地降低系统的性能。interbase和大多数关系数据库一样，采用的是乐观锁，而且读锁是共享的，写锁是排他的。可以在一个读锁上再放置读锁，但不能再放置写锁；你不能在写锁上再放置任何锁。锁是目前解决多用户并发访问的有效手段。  [乐观锁与悲观锁的区别](http://www.cnblogs.com/Bob-FD/p/3352216.html)</code></pre><p>数据库范式</p><pre><code>1NF的定义为：符合1NF的关系中的每个属性都不可再分,1NF是所有关系型数据库的最基本要求，2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。BCNF范式在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。</code></pre><p><a href="http://www.zhihu.com/question/24696366">解释一下关系数据库的第一第二第三范式？</a></p><p>数据库日志类型作用</p><pre><code>MySQL日志文件分类1.错误日志(Error Log)2.二进制日志(Binary Log &amp; Binary Log Index)3.通用查询日志(query log)4.慢查询日志(slow query log)5.Innodb的在线 redo 日志(innodb redo log)6.更新日志(update log)</code></pre><p>innodb和myisam的区别</p><pre><code>innodb，聚集索引，支持外键和事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))，不支持全文索引，不支持计数，统计的时候会遍历，myisam，非聚集索引，不支持外键事务，支持全文索引，支持计数，查询效果较好</code></pre><p>你对innodb哪里最熟悉</p><p>innodb的索引有哪几种类型</p><pre><code>4种，hash，b-tree，spatial，full-text1. B-Tree索引最常见的索引类型，基于B-Tree数据结构。B-Tree的基本思想是，所有值（被索引的列）都是排过序的，每个叶节点到跟节点距离相等。所以B-Tree适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）。但是当索引多列时，列的顺序特别重要，需要格外注意。InnoDB和MyISAM都支持B-Tree索引。InnoDB用的是一个变种B+Tree，而MyISAM为了节省空间对索引进行了压缩，从而牺牲了性能。2. Hash索引基于hash表。所以这种索引只支持精确查找，不支持范围查找，不支持排序。这意味着范围查找或ORDER BY都要依赖server层的额外工作。目前只有Memory引擎支持显式的hash索引（但是它的hash是nonunique的，冲突太多时也会影响查找性能）。Memory引擎默认的索引类型即是Hash索引，虽然它也支持B-Tree索引。Hash 索引仅仅能满足&quot;=&quot;,&quot;IN&quot;和&quot;&lt;=&gt;&quot;查询，不能使用范围查询。例子：CREATE TABLE testhash (    fname VARCHAR(50) NOT NULL,    lname VARCHAR(50) NOT NULL,    KEY USING HASH(fname)) ENGINE =MEMORY;3. Spatial (R-Tree)（空间）索引只有MyISAM引擎支持，并且支持的不好。可以忽略。4. Full-text索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。Full-text索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的WHERE语句的参数匹配。你可以对某列分别进行full-text索引和B-Tree索引，两者互不冲突。Full-text索引配合MATCH AGAINST操作使用，而不是一般的WHERE语句加LIKE。http://segmentfault.com/q/1010000003832312</code></pre><p>B TREE 和B+TREE的区别</p><p>innodb有全文索引吗</p><pre><code>没有，myisam有</code></pre><p>union和join</p><pre><code>JOIN用于按照ON条件联接两个表，主要有四种：INNER JOIN：内部联接两个表中的记录，仅当至少有一个同属于两表的行符合联接条件时，内联接才返回行。我理解的是只要记录不符合ON条件，就不会显示在结果集内。LEFT JOIN / LEFT OUTER JOIN：外部联接两个表中的记录，并包含左表中的全部记录。如果左表的某记录在右表中没有匹配记录，则在相关联的结果集中右表的所有选择列表列均为空值。理解为即使不符合ON条件，左表中的记录也全部显示出来，且结果集中该类记录的右表字段为空值。RIGHT JOIN / RIGHT OUTER JOIN：外部联接两个表中的记录，并包含右表中的全部记录。简单说就是和LEFT JOIN反过来。FULL JOIN / FULL OUTER JOIN： 完整外部联接返回左表和右表中的所有行。就是LEFT JOIN和RIGHT JOIN和合并，左右两表的数据都全部显示。JOIN的基本语法：Select table1.* FROM table1 JOIN table2 ON table1.id=table2.idUNION运算符将两个或更多查询的结果集组合为单个结果集，该结果集包含联合查询中的所有查询的全部行。UNION的结果集列名与UNION运算符中第一个Select语句的结果集的列名相同。另一个Select语句的结果集列名将被忽略。其中两种不同的用法是UNION和UNION ALL，区别在于UNION从结果集中删除重复的行。如果使用UNION ALL 将包含所有行并且将不删除重复的行。相同点：在某些特定的情况下，可以用join实现union all的功能，这种情况是有条件的，当出现这种情况的时候选择union all还是group by就可以看情况或者看两者的消耗而决定。http://chengheng1984.blog.163.com/blog/static/17947412201012215738844/http://www.51testing.com/html/14/446214-249265.html</code></pre><h2 id="海量数据处理：">海量数据处理：</h2><p>bitmap</p><p>Map-Reduce原理，</p><p>BloomFilter原理、</p><pre><code>它实际上是一个很长的二进制向量和一系列随机映射函数（Hash函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。Bloom Filter广泛的应用于各种需要查询的场合中，如Orocle的数据库，Google的BitTable也用了此技术。Bloom Filter特点：不存在漏报（False Negative），即某个元素在某个集合中，肯定能报出来。可能存在误报（False Positive），即某个元素不在某个集合中，可能也被爆出来。确定某个元素是否在某个集合中的代价和总的元素数目无关。</code></pre><p>Trie树原理、<br>单词搜索树</p><p>B+树原理，</p><p>LSM树原理,</p><p>大数据处理</p><h2 id="工具：">工具：</h2><p>编译工具GCC，调试工具GDB，性能优化工具Perf,内存泄露检查工具Valgrind,makefile编写<br>其他工具: netstat,ps,top,df,fdisk,lsof，ifconfig,uname,kill，tcpdump，ipcs，grep</p><h2 id="其他：安全，加密方式（DES，SHA）">其他：安全，加密方式（DES，SHA）</h2><p>附：<a href="http://blog.csdn.net/programmer_editor/article/details/4004408">软件开发者面试百问</a></p><h1>相关书籍</h1><pre><code>语言类：C:C程序设计语言（K&amp;R）-&gt;C和指针-&gt;C专家编程-&gt;C陷阱与缺陷-&gt;你必须知道的495个C语言问题C++: C++ primer -&gt; effective C++-&gt;深度探索C++对象模型 -&gt;stl源码分析-&gt;C++必知必会java：java编程思想-&gt;java并发编程-&gt;深入理解Java虚拟机：JVM高级特性与最佳实践 算法和数据结构：算法导论-&gt;数据结构与算法分析(维斯)-&gt;编程之美-&gt;剑指offer 操作系统：深入理解计算机操作系统-&gt;编译原理（龙书）鸟哥的linux私房菜-&gt;linux内核设计与实现-&gt;深入理解linux内核linux shell脚本攻略（短小精悍）网络编程： TCP/IP协议详解v1-&gt;unix高级环境编程-&gt;unix网络编程（卷1&amp;卷2）-&gt;unix编程艺术(进阶)视野：大型网站技术架构：核心原理与案例分析，深入理解nginx：模块开发与架构解析，大规模分布式存储系统 : 原理解析与架构实战其他：程序员自我修养，重构，编写可读代码的艺术，headfirst设计模式</code></pre><h1>相关网络资源</h1><pre><code>Coolshell：http://coolshell.cn/Matrix67大牛的博客：http://www.matrix67.com/blog/。July的CSDN博客：http://blog.csdn.net/v_JULY_v。何海涛博客：http://zhedahht.blog.163.com/。笔试面试的经典：Cracking the coding interview--问题与解答：http://hawstein.com/posts/ctci-solutions-contents.htmlLeetCode：http://leetcode.com/这里有不少笔试题集锦：http://blog.csdn.net/hackbuteer1程序员编程艺术：面试和算法心得http://taop.marchtea.com/</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;后端开发面试题&lt;/h1&gt;
&lt;h1&gt;后端开发面试知识点大纲：&lt;/h1&gt;
&lt;h2 id=&quot;语言类（C-）：&quot;&gt;语言类（C++）：&lt;/h2&gt;
&lt;h3 id=&quot;关键字作用解释：&quot;&gt;关键字作用解释：&lt;/h3&gt;
&lt;p&gt;volatile作用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Volatil</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Avl_tree</title>
    <link href="https://lwscode.cn/p/51743/"/>
    <id>https://lwscode.cn/p/51743/</id>
    <published>2021-04-20T02:42:00.000Z</published>
    <updated>2021-04-26T11:15:10.709Z</updated>
    
    <content type="html"><![CDATA[<h1>avl_tree</h1><h2 id="节点数">节点数</h2><p>在高度为h的avl树中，最少节点数low(h)</p><p>low(h) = low(h - 1) + low(h - 2) + 1low(0) = 1 low(1) = 2</p><p>最大节点数max(h)</p><p>max(h) = 2^h - 1</p><h2 id="平衡">平衡</h2><p>LL型 右旋</p><p>RR型 左旋</p><p>LR型 左旋–&gt;(LL型)–&gt;右旋</p><p>RL型 右旋–&gt;(RR型)–&gt;左旋</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;avl_tree&lt;/h1&gt;
&lt;h2 id=&quot;节点数&quot;&gt;节点数&lt;/h2&gt;
&lt;p&gt;在高度为h的avl树中，最少节点数low(h)&lt;/p&gt;
&lt;p&gt;low(h) = low(h - 1) + low(h - 2) + 1	low(0) = 1 low(1) = 2&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
